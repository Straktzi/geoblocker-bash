#!/bin/bash -l

# geoblocker-bash-apply

# Creates or removes ipsets and iptables rules for specified country codes.

# Requires the 'ipset' utility. To install it on Debian or derivatives, use the command:
## apt install ipset
#
# Requires root priviliges


#### Initial setup

me=$(basename "$0")

# check for root
[[ "$EUID" -ne 0 ]] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	[[ ! "$nolog" ]] && logger "$err"
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[[ -n "$script_dir" ]] && cd "$script_dir" || { err="$me: Error: Couldn't cd into '$script_dir'."; echo "$err" >&2; \
	[[ ! "$nolog" ]] && logger "$err"; exit 1; }

source "$script_dir/${suite_name}-common" || { err="$me: Error: Can't source ${suite_name}-common."; echo "$err" >&2; \
	[[ ! "$nolog" ]] && logger "$err"; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {
    cat <<EOF

$me
    Loads or removes ipsets and iptables rules for specified country codes.
	If 'NoDrop' option is set to "true" in the config file (set up during installation): will perform the action,
        except setting default iptables policies to DROP, which for a whitelist effectively leaves geoblocking *disabled*.
        (NoDrop does not affect blacklist functionality)

Usage: $me <action> -c <"country_codes"> [-d] [-t] [-h]

Actions:
    add|remove                 : Add or remove ipsets and iptables rules for country codes specified with the '-c' option

Options:
    -c <"country_codes">       :  (ISO 3166-1 alpha-2) country codes (if specifying multiple country codes, put them in double quotes)

    -d                         : Debug
    -t                         : Simulate fault and test recovery
    -h                         : This help

EOF
}

#### PARSE ARGUMENTS

# 1st argument should be the requested action
action="$1"
shift 1

[[ -z "$action" ]] && { usage; die 1 "Specify action!"; }

# check for valid action
case "$action" in
	add | remove ) ;;
	* ) usage; err1="Error: Unrecognized action: '$action'."; err2="Specify action in the 1st argument!"; die "$err1" "$err2" ;;
esac

# process the rest of the arguments
while getopts ":c:dht" opt; do
	case $opt in
		c) ccodes=$OPTARG;;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; die "Error: Unknown option: '$OPTARG'." ;;
	esac
done
shift $((OPTIND -1))

[[ -n "$*" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them in double quotation marks."
	die "$err1" "$err2"
}

echo

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg

#### FUNCTIONS

round_up_to_power2() {
# rounds the input number up to the next high power of 2
	echo "\
		if($1==0) x=0 else \
			x=l($1)/l(2); \
		scale=0; \
		y=2^((x+1)/1); \
		if($1==y/2 && $1!=1) \
			print $1 \
		else \
			print y"\
	 | bc -l
}

destroy_temp_ipsets() {
	curr_temp_ipsets="$(ipset list -n | grep "$suite_name" | grep "temp" | tr '\n' ' ' | awk '{$1=$1};1')"
	for temp_ipset in $curr_temp_ipsets; do
		ipset destroy "$temp_ipset" &> /dev/null
	done
}

getlocalsubnet() {
# attempts to find local subnet for the main network interface

	# regex patterns used for ipv4 validation
	# using Perl regex syntax because grep is faster with it than with native grep syntax
	# regex compiled from 2 suggestions found here:
	# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
	ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
	mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
	subnet_regex="${ip_regex}${mask_regex}"

	# returns local ip with subnet mask
	localip="$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}')"

	# Change last ipv4 octet to 0
	lsubnet="$(printf "%s" "$localip" | sed 's|\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*|\10|')"

	# Verifies that the argument is a valid ipv4 subnet
	printf "%s" "$lsubnet" | grep -P "$subnet_regex" &>/dev/null; rv=$?

	if [[ $rv -ne 0 ]]; then
		# if validation fails, output empty string
		printf "%s" ""
	else
		printf "%s" "$lsubnet"
	fi
	return $rv
}


#### VARIABLES

# get datadir from the config file
datadir="$(getconfig "Datadir")" || die "Error: Couldn't read value for Datadir from the config file."

# get list_type from the config file
list_type="$(getconfig "ListType")" || die "Error: Couldn't read value for ListType from the config file."

# set global variable
export list_type="$list_type"

nodrop="$(getconfig "NoDrop")" || die "Error: Couldn't read value for NoDrop from the config file."
iplist_dir="${datadir}/ip_lists"
iptables_comment_global="${suite_name}_global"
family="inet"
ipset_hashsizes=()
ipset_maxelements=()

# convert to lower case
action="${action,,}"


exitvalue="0"


#### CHECKS

missing_deps="$(check_deps iptables-save iptables-restore ipset)" || die "Error: missing dependencies: $missing_deps."

# check that the config file exists
[[ ! -f "$conf_file" ]] && die "Config file '$conf_file' doesn't exist! Run the installation script again."

# check for ccodes
[[ -z "$ccodes" ]] && { usage; die 254 "Specify country codes!"; }

# check for datadir path
[[ -z "$datadir" ]] && die 254 "Error: failed to read the 'datadir' variable from the config file."

[[ -z "$list_type" ]] && die "\$list_type variable should not be empty! Something is wrong!"


#### MAIN

if [[ "$action" = "add" ]]; then
### create temporary ipsets and load ip lists into them

	for ccode in $ccodes; do
		iplist_file="${iplist_dir}/ipv4_${ccode}"
		temp_ipset="${suite_name}_${ccode}_temp"

		# check that the iplist file exists
		[[ ! -f "$iplist_file" ]] && die 254 "Error: Can not find the iplist file in path: '$iplist_file'."

		# first destroy temporary ipset with that name in case it exists
		ipset destroy "$temp_ipset" &>/dev/null

		# count lines in the iplist file
		ip_cnt=$(wc -l < "$iplist_file")
	#	debugprint "ip count in the iplist file '$iplist_file': $ip_cnt"

		# calculate necessary ipset size = (next high power of 2 > $ip_cnt)
		ipset_maxelem=$(round_up_to_power2 "$ip_cnt")
	#	debugprint "calculated maxelem for ipset: $ipset_maxelem"

		# set hashsize to (512) or (ipset_maxelements / 4), whichever is larger
		prelim_hashsize=$(echo "scale=0 ; $ipset_maxelem / 4" | bc)
	#	debugprint "calculated hashsize: $prelim_hashsize"
		if [[ "$prelim_hashsize" -lt 512 ]]; then
			ipset_hash=512
		else
			ipset_hash="$prelim_hashsize"
		fi
	#	debugprint "final hashsize for the new ipset: $ipset_hashsizes"

		# create new temporary ipset
		debugprint "Creating new ipset '$temp_ipset'... "
		ipset create "$temp_ipset" hash:net family "$family" hashsize "$ipset_hash" maxelem "$ipset_maxelem"; rv=$?
		if [[ $rv -ne 0 ]]; then
			destroy_temp_ipsets
			die "Error creating ipset '$temp_ipset' with hashsize '$ipset_hash' and maxelements '$ipset_maxelem'."
		fi
		debugprint "Ok."

		# import the iplist into temporary ipset from file
		echo -n "Importing the iplist for country '$ccode' into temporary ipset... "

		# reads $iplist_file, transforms each line into 'ipset add' command and redirects the result into "ipset restore"
		# this is about 50x faster than issuing discrete "ipset add" commands in a loop
		# using awk to process the text lines rather than native bash construct "while read -r line ... do < $iplist_file"
		#    is yet about 4x faster for a large iplist
		# the '-exist' option prevents the restore command from getting stuck when encountering duplicates

		awk -v P="add \"$temp_ipset\"" '{ print P " " $0 }' "$iplist_file" | ipset restore -exist; rv=$?

		if [[ $rv -ne 0 ]]; then
			destroy_temp_ipsets
			die 254 "Error when importing the list from '$iplist_file' into ipset '$temp_ipset'."
		fi

		echo "Ok."

		[[ "$debugmode" ]] && ipset_lines_cnt="$(ipset save "$temp_ipset" | grep "add $temp_ipset" | wc -l)"
		debugprint "subnets in the temporary ipset: $ipset_lines_cnt"

		ipset_hashsizes["$ccode"]="$ipset_hash"
		ipset_maxelements["$ccode"]="$ipset_maxelem"
	done
	echo
fi


### Remove existing geoblocker rules for iptables

if [[ "$list_type" = "whitelist" ]]; then
	## Temporarily set the policy for the INPUT chain to ACCEPT, in order to prevent user lock out in case of an error
	echo -n "Setting INPUT chain policy to ACCEPT... "
	iptables -P INPUT ACCEPT; rv=$?
	[[ $rv -ne 0 ]] && die "Error trying to change iptables policy with command 'iptables -P INPUT ACCEPT'."
	echo "Ok."
	echo
fi

## delete existing iptables rules matching comment "$iptables_comment"
for ccode in $ccodes; do
	iptables_comment="${suite_name}_${ccode}"
	echo -n "Removing existing $list_type iptables rules for country '$ccode'... "

	# sed looks for rules with the comment which we use to stamp our rules
	# sed executes iptables -D (delete) command on matching rules. execution is promtped by the switch /e (only available in GNU sed)
	iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null; rv="${PIPESTATUS[0]}"
	if [[ $rv -ne 0 ]]; then
		echo "Failed."
		destroy_temp_ipsets
		die "Error removing existing rules with command: 'iptables-save | sed -r \"/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e\" '."
	fi
	echo "Ok."
done

echo


## delete existing iptables rules matching comment "$iptables_comment_global"
echo -n "Removing existing global iptables rules for '${suite_name}'... "
iptables-save | sed -r "/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e" &>/dev/null; rv="${PIPESTATUS[0]}"
if [[ $rv -ne 0 ]]; then
	echo "Failed."
	destroy_temp_ipsets
	die "Error removing existing rules with command: 'iptables-save | sed -r \"/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e\" '."
fi
echo "Ok."
echo


### Apply the "remove" action

if [[ "$action" = "remove" ]]; then
	for ccode in $ccodes; do
		perm_ipset="${suite_name}_${ccode}"

		# Check if given ipset exists
		matching_ipset="$(ipset list -n | grep "$perm_ipset")"
		if [[ -z "$matching_ipset" ]]; then
			echo "Warning: Can't remove ipset '$perm_ipset' because it doesn't appear to exist."
			exitvalue="254"
		else
			echo -n "Destroying ipset for country '$ccode'... "
			sleep 0.8
			ipset destroy "$perm_ipset"; rv=$?
			if [[ $rv -ne 0 ]]; then
				echo "Failed."
				destroy_temp_ipsets
				die "Error destroying ipset '$perm_ipset'."
			else
				echo "Ok."
			fi
		fi
	done
	echo
fi

# these are only useful for whitelists
if [[ "$list_type" = "whitelist" ]]; then

	### Set global iptables rules

	# Add rule to allow connections from the local network
	localsubnet="$(getlocalsubnet)"
	if [[ -z "$localsubnet" ]]; then
		destroy_temp_ipsets
		die "Error: couldn't determine local subnet."
	else
		echo "Found local subnet: '$localsubnet'."
		echo -n "Appending rule to allow all traffic from the local subnet... "
		iptables -A INPUT -s "$localsubnet" -j ACCEPT -m comment --comment "${iptables_comment_global}-localsubnet"; rv=$?

		if [[ $rv -ne 0 ]]; then
			destroy_temp_ipsets
			die "Failed to append rule with command 'iptables -A INPUT -s \"$localsubnet\" -j ACCEPT'."
		fi
		echo "Ok."
	fi

	# Add rule to allow connections from the loopback interface
	echo -n "Inserting rule to allow all traffic from the loopback interface... "
	iptables -I INPUT -i lo -j ACCEPT -m comment --comment "${iptables_comment_global}-loopback-interface"; rv=$?

	if [[ $rv -ne 0 ]]; then
		destroy_temp_ipsets
		die "Failed to insert rule with command 'iptables -I INPUT -i lo -j ACCEPT'."
	fi
	echo "Ok."

	echo
fi

# Add rule to allow established/related connections, regardless of the firewall mode (whitelist or blacklist)
echo -n "Inserting rule to allow established/related connections... "
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "${iptables_comment_global}-established-related"; rv=$?

if [[ $rv -ne 0 ]]; then
	destroy_temp_ipsets
	die "Failed to insert rules with command 'iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT'."
fi
echo "Ok."

### Create permanent ipsets if they don't exist, add iptables rules for them, then swap them with temp ipsets
if [[ "$action" = "add" ]]; then
	for ccode in $ccodes; do
		perm_ipset="${suite_name}_${ccode}"
		temp_ipset="${suite_name}_${ccode}_temp"
		iptables_comment="${suite_name}_${ccode}"
		ipset_maxelem="${ipset_maxelements[$ccode]}"
		ipset_hash="${ipset_hashsizes[$ccode]}"

		## check if permanent ipset already exists and is non-empty

		ipset_length=$(ipset -L "$perm_ipset" 2>/dev/null |  wc -l)

		if [[ "$ipset_length" -ge 7 ]]; then
			perm_ipset_exists="true"
			debugprint "found existing permanent ipset '$perm_ipset'."
		else
			perm_ipset_exists=""
		fi

		if [[ "$ipset_length" -eq 0 ]]; then
			debugprint "Ipset '$perm_ipset' doesn't exist yet."
			# to avoid being dependent on ipset output staying constant down the road,
			# still trying to destroy the ipset, just in case, but not checking the return value
			sleep 0.5
			ipset destroy "$perm_ipset" &>/dev/null
		fi

		## if permanent ipset doesn't exist yet, create it
		if [[ ! "$perm_ipset_exists" ]]; then
			# create new permanent ipset
			debugprint "Creating permanent ipset '$perm_ipset'... "
			ipset create "$perm_ipset" hash:net family "$family" hashsize "$ipset_hash" maxelem "$ipset_maxelem"; rv=$?
			if [[ $rv -ne 0 ]]; then
				echo "Failed."
				iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null
				sleep 0.8
				ipset destroy "$perm_ipset"
				destroy_temp_ipsets
				die "Error when creating ipset '$perm_ipset'."
			fi
			debugprint "Ok."
		fi

		## append the iplist rule to the INPUT chain


		if [[ "$list_type" = "whitelist" ]]; then iptables_action="ACCEPT"; else iptables_action="DROP"; fi

		echo -n "Appending $list_type rule for country '$ccode' to the INPUT chain... "
		iptables -A INPUT -m set --match-set "$perm_ipset" src -j "$iptables_action" -m comment --comment "$iptables_comment"; rv=$?

		if [[ $rv -ne 0 ]]; then
			iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null
			sleep 0.8
			ipset destroy "$perm_ipset" &>/dev/null
			destroy_temp_ipsets
			die "Failed to append ipset rules with command: iptables -I INPUT -m set --match-set \"$perm_ipset\" src -j \"$iptables_action\"."
		fi
		echo "Ok."

		## swap the new (temporary) ipset with the old (permanent) ipset
		echo -n "Making the new $list_type ipset for country '$ccode' permanent... "
		ipset swap "$temp_ipset" "$perm_ipset"; rv=$?
		if [[ $rv -ne 0 ]]; then
			iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null
			sleep 0.8
			ipset destroy "$perm_ipset" &>/dev/null
			destroy_temp_ipsets
			die "Failed to swap temporary and permanent ipsets."
		fi

		echo "Ok."

		## destroy the old ipset (now it's called temporary)
		debugprint "Destroying the temporary ipset for country '$ccode'... "
		ipset destroy "$temp_ipset"; rv=$?
		[[ $rv -ne 0 ]] && die "Failed to destroy ipset '$temp_ipset'. Strange........."
		debugprint "Ok."
	done
fi
echo


### Configure iptables policies

# DROP policies are only used for whitelists
if [[ "$list_type" = "whitelist" ]]; then
	if [[ ! "$nodrop" ]]; then
		# set policy on INPUT and FORWARD chains to DROP
		echo -n "Setting default iptables policies for INPUT and FORWARD chains to DROP... "
		iptables -P INPUT DROP; rv=$?
		[[ $rv -ne 0 ]] && die "Failed to change iptables policy with command 'iptables -P INPUT DROP'."

		iptables -P FORWARD DROP; rv=$?
		[[ $rv -ne 0 ]] && die "Failed to change iptables policy with command 'iptables -P FORWARD DROP'."
		echo "Ok."
	else
		echo "WARNING: nodrop was requested. Leaving INPUT and FORWARD chains with ACCEPT policies (geoblocking is inactive)."
	fi
else
	# set policy on INPUT chain to ACCEPT
	echo -n "Setting default iptables policy for INPUT chains to ACCEPT... "
	iptables -P INPUT ACCEPT; rv=$?
	[[ $rv -ne 0 ]] && die "Failed to change iptables policy with command 'iptables -P INPUT ACCEPT'."

fi

# This line is to simulate a simple fault and test recovery from backup
# Activates when running the script with the -t switch
[[ "$test" ]] && die "Test test test"

echo

debugexitmsg

exit "$exitvalue"
