#!/usr/bin/env bash

# geoblocker_bash-install

# Installer for geoip blocking suite of bash scripts
# Must be run as root

# Creates system folder structure for scripts, config and data.
# Copies all scripts included in the suite to /usr/local/bin.
# Creates backup of pre-install policies for INPUT and FORWARD chains.
# Calls geoblocker_bash-manage to set up geoblocker and then call the -fetch and -apply scripts.
# If an error occurs during installation, calls the uninstall script to revert any changes made to the system.
# Accepts a custom cron schedule expression as an argument. Default cron schedule is "0 4 * * *" - at 4:00 [am] every day.

# Requires the following additional scripts (included in the distribution):
# geoblocker_bash-fetch, geoblocker_bash-apply, geoblocker_bash-run, geoblocker_bash-uninstall, validate_cron_schedule.sh, check_ip_in_ripe.sh

me=$(basename "$0")
args="$*"

#### USAGE

usage() {

    cat <<EOF

$me
Installer for geoip blocking suite of bash scripts.
Must be run as root.

This script:
1) Creates system folder structure for scripts, config and data.
2) Copies all scripts included in the suite to /usr/local/bin.
3) Creates backup of pre-install policies for INPUT and FORWARD chains.
4) Calls geoblocker_bash-manage to set up geoblocker and then call the -fetch and -apply scripts.
5) If an error occurs during installation, calls the uninstall script to revert any changes made to the system.
6) Accepts a custom cron schedule expression as an argument. Default cron schedule is "0 4 * * *" - at 4:00 [am] every day.

    Usage: $me -c <"tld [tld] ... [tld]"> [-s "<schedule_expression>"] [-n] [-p] [-d] [-h]

    Options:
        -c <"tld(s)">        : tld / country codes. if passing multiple country codes, use double quotes
        -s "sch_expression"  : schedule expression for the cron job, must be inside double quotes
                                  default: "0 4 * * *" (at 4:00 [am] every day)

        -p                   : No Drop: applies the config but skips setting INPUT chain default policy to DROP
        -n                   : No persistence (will not create cron jobs)
        -d                   : Debug
        -h                   : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "c:s:npdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		n) no_persistence="-n";;
		p) nodrop="-p";;
		d) debug="-d";;
		h) usage; exit 0;;
		\?) usage; exit 1;;
	esac
done


#### FUNCTIONS

debugprint() {
# prints a debug message
	[ "$debug" ] && echo -e "    Debug: $*"
}

echo ""
debugprint "\033[1;33mStarted *install with args: '$args'\033[0m"

setconfig() {
# changes a field named $1 in the config file $2 to value $3
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	field="$3"
	if [ -z "$fieldname" ] || [ -z "$configfile" ] || [ -z "$field" ]; then return 1; fi

	# create the config file if it doesn't exist
	touch "$conf_file"; rv01=$?

	# remove corresponding config line
	cat "$configfile" | grep -v "$fieldname=" > "${configfile}.temp"
	mv "${configfile}.temp" "$configfile"; rv02=$?

	# add updated config line
	echo -e "$fieldname=$field" >> "$configfile"; rv03=$?
	rv0=$(( rv01 + rv02 + rv03 ))
	return $rv0
}

get_script_dir () {
	SOURCE=${BASH_SOURCE[0]}
	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
		SOURCE=$(readlink "$SOURCE")
		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
		# if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	done
	DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
	echo "$DIR"
}

install_failed() {
	echo "Error: Installation failed." >&2
	echo "Uninstalling geoblocker_bash..."
	bash geoblocker_bash-uninstall
	exit 1
}

check_file_exists() {
if [ ! -f "$1" ]; then
	echo "Error: Cannot find $1" >&2
	echo ""
	exit 1
fi
}

copyscript() {
	scriptfile="$1"; destination="$2"
	errormessage="Error copying $scriptfile to $destination. Exiting."
	cp "$scriptfile" "$destination"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "$errormessage" >&2
		echo ""
		install_failed
	fi
	chmod +x "${install_dir}/$scriptfile"
}


#### VARIABLES
install_dir="/usr/local/bin"
datadir="/var/lib/geoblocker_bash"
preinstall_policies_file="${datadir}/preinstall_policies.bak"
knowngood_file="${datadir}/iptables_knowngood.bak"
whitelist_dir="${datadir}/ip_lists"
backup_script="${install_dir}/geoblocker_bash-backup"

conf_dir="/etc/geoblocker_bash"
conf_file="${conf_dir}/geoblocker_bash.conf"

default_schedule="0 4 * * *"
cron_schedule="${cron_schedule:-$default_schedule}"
sleeptime="30"

run_command="${install_dir}/geoblocker_bash-run"
run_args="-c \"$tlds\" -w \"$whitelist_dir\" -b \"$knowngood_file\""
run_args_reboot="${run_args} -s"


#### CHECKS

if [ -z "$tlds" ]; then
	usage
	echo "Specify countries with \"-c <tlds>\"!"
	echo ""
	exit 1
fi

# check for root
if [ "$EUID" -ne 0 ]; then
	echo "This needs to be run as root."
	echo ""
	exit 1
fi

# check for systemd
if [ "$(! ps -p 1 -o comm=)" != "systemd" ]; then
	echo "Error: systemd is required but this sytem does not appear to be running systemd. Exiting."
	echo ""
	exit 1
fi

# check for curl or wget
curl_or_wget=$(if hash curl 2>/dev/null; then echo "curl -s"; elif hash wget 2>/dev/null; then echo "wget -qO-"; fi);
if [ -z "$curl_or_wget" ]; then
	echo "Error: Neither curl nor wget found. Exiting."
	echo ""
	exit 1
fi

# Check that we have the ipset utility
if ! command -v "ipset" &> /dev/null; then
	echo "Error: Cannot find 'ipset'. Install it with 'apt install ipset' or similar. Exiting."
	echo ""
	exit 1
fi

# Check for iptables-save utility
if ! command -v "iptables-save" &> /dev/null; then
	echo "Error: Cannot find 'iptables-save'. Exiting."
	echo ""
	exit 1
fi

# Check for iptables-restore utility
if ! command -v "iptables-restore" &> /dev/null; then
	echo "Error: Cannot find 'iptables-restore'. Exiting."
	echo ""
	exit 1
fi

# check for jq
if ! command -v jq &> /dev/null; then
	echo "Error: Cannot find the jq Json processor. Install it with 'apt install jq' or similar. Exiting"
	echo ""
	exit 1
fi

# check for grepcidr
if ! command -v grepcidr &> /dev/null; then
	echo "Error: Cannot find grepcidr. Install it with 'apt install grepcidr' or similar. Exiting"
	echo ""
	exit 1
fi

# check for bc
if ! command -v bc &> /dev/null; then
	echo "Error: Cannot find bc. Exiting"
	echo ""
	exit 1
fi

scriptdir="$(get_script_dir)"
# cd into script directory
# exit in case "cd" fails
cd "$scriptdir"; rv=$?
if [ -z "$scriptdir" ] || [ "$rv" -ne 0 ]; then echo "Error: could not change directory to \"$scriptdir\". Exiting."; exit 1; fi

check_file_exists "geoblocker_bash-fetch"
check_file_exists "geoblocker_bash-apply"
check_file_exists "geoblocker_bash-run"
check_file_exists "geoblocker_bash-manage"
check_file_exists "geoblocker_bash-backup"
check_file_exists "geoblocker_bash-uninstall"
check_file_exists "validate_cron_schedule.sh"
check_file_exists "check_ip_in_ripe.sh"


#### MAIN

# Create the directory for config and, if required, parent directories
mkdir -p "$conf_dir"

# delete config file if it exists
rm "$conf_file" &> /dev/null

# write some config to the config file
echo -n "Setting initial config... "
setconfig "Installdir" "$conf_file" "$install_dir"; rv=$(( rv + $?))
setconfig "Datadir" "$conf_file" "$datadir"; rv=$(( rv + $?))
setconfig "Cron_schedule" "$conf_file" "$cron_schedule"; rv=$(( rv + $?))
setconfig "RebootSleep" "$conf_file" "$sleeptime"; rv=$(( rv + $?))
setconfig "Backup_script" "$conf_file" "$backup_script"; rv=$(( rv + $?))
if [ "$rv" -ne 0 ]; then
	echo "Failed."
	install_failed
else echo "Ok."
fi

# Create the directory for downloaded lists and, if required, parent directories
mkdir -p "$whitelist_dir"


## Create a backup file for known-good iptables state

echo -n "Creating file for backup of iptables state..."

# if a backup file already exists, continue installing but skip overwriting the backup file
if [ -f "$knowngood_file" ]; then
	echo "Backup file already exists, skipping."
else
	touch "$knowngood_file"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Error."
		install_failed
	fi
	echo "Ok."
fi

## Copy scripts to $install_dir

# if we are running from $install_dir, assume that all other necessary scripts have already been installed, skip copying
if [ "$scriptdir" != "$install_dir" ]; then
	echo -n "Copying scripts to $install_dir... "
	copyscript "geoblocker_bash-install" "${install_dir}/"
	copyscript "geoblocker_bash-fetch" "${install_dir}/"
	copyscript "geoblocker_bash-apply" "${install_dir}/"
	copyscript "geoblocker_bash-run" "${install_dir}/"
	copyscript "geoblocker_bash-manage" "${install_dir}/"
	copyscript "geoblocker_bash-backup" "${install_dir}/"
	copyscript "geoblocker_bash-uninstall" "${install_dir}/"
	copyscript "validate_cron_schedule.sh" "${install_dir}/"
	copyscript "check_ip_in_ripe.sh" "${install_dir}/"
	echo "Ok."
fi


### Back up pre-install policies for INPUT and FORWARD chains

echo -n "Creating backup of current INPUT and FORWARD iptables chains policies... "

# if a backup file already exists, continue installing but skip overwriting the backup file
if [ -f "$preinstall_policies_file" ]; then
	echo "Backup file already exists, skipping creation of iptables policies backup." >&2
else
	preinstall_input_policy=$(iptables -nL | grep "Chain INPUT" | awk -F'policy |)' '{print $2}')
	preinstall_forward_policy=$(iptables -nL | grep "Chain FORWARD" | awk -F'policy |)' '{print $2}')
	if [ -z "$preinstall_input_policy" ] || [ -z "$preinstall_forward_policy" ]; then
		echo "Error: failed to determine current policies."
		install_failed
	fi
	touch "$preinstall_policies_file"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Error: failed to create backup file." >&2
		install_failed
	fi
	echo "INPUT $preinstall_input_policy" >> "$preinstall_policies_file"
	echo "FORWARD $preinstall_forward_policy" >> "$preinstall_policies_file"
	echo "Ok."
	[ $debug ] && echo ""
	[ $debug ] && echo "Current policies:"
	[ $debug ] && echo "INPUT: $preinstall_input_policy, FORWARD: $preinstall_forward_policy"
fi

# cd into the install directory
# exit in case "cd" fails
cd "$install_dir"; rv=$?
if [ -z "$install_dir" ] || [ "$rv" -ne 0 ]; then echo "Error: could not change directory to \"$install_dir\". Exiting."; install_failed; fi

manage_opts=( "$debug" "$no_persistence" "$nodrop" -a "add" )
### Add whitelist(s) for $tlds to managed whitelists, then fetch and apply the whitelist(s)
# have to use array to prevent getopts errors. have to provide cron schedule separately to prevent * expansion
geoblocker_bash-manage ${manage_opts[*]} -c "$tlds" -s "$cron_schedule"; rv=$?

if [ $rv -ne 0 ]; then
	echo "Failed to create and apply the whitelist."
	install_failed
fi

echo "Install done."

echo ""
