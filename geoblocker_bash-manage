#!/usr/bin/env bash

# geoblocker_bash-manage

# Provides an interface to configure geoblocking.

# Supported actions: add, remove, schedule.

# 'geoblocker_bash-manage -a add|remove -c <country_code>' :
#     Adds or removes the specified country codes (tld's) to/from the config file.
#     Calls the -run script to fetch and apply the ip lists.
#     Sets up or disables persistence via the -cronsetup script.
#     Calls the -backup script to create a backup of current config, ipsets and iptables state.

# 'geoblocker_bash-manage -a schedule -s <"schedule_expression">' : enables persistence
#     and configures the schedule for the periodic cron job.
# 'geoblocker_bash-manage -a schedule -s disable' : disables persistence.


#### Initial setup

me=$(basename "$0")
suite_name="geoblocker_bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { echo "Error: Couldn't cd into '$script_dir'."; exit 1; }

source "$script_dir/${suite_name}-common" || { echo "Error: Can't find ${suite_name}-common."; exit 1; }
# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"

#### USAGE

usage() {
    cat <<EOF

$me
    Provides an interface to configure geoblocking.

WARNING: if removing a whitelist: Geoblocking will remain active after removal.
         If you remove your country's whitelist, you may lose remote access to your system.


Usage: $me -a <action> [-c "[tld] [tld] ... [tld]"] [-s <"sch_expression"|disable>] [-f] [-t] [-d] [-h]

Options:
    -a add|remove|schedule        : action to perform: add or remove ipsets, iptables rules and cron jobs
                                       or "schedule" to change the cron schedule (has no effect on iptables rules).

    -c "tld(s)"                   : tld / country codes. if passing multiple country codes, use double quotes.
    -s <"sch_expression">|disable : schedule expression for the periodic cron job, must be inside double quotes.
                                       "disable" removes cron jobs and turns off persistence.

    -f                            : Force the action even if it doesn't make sense or may cause remote server lockout.

    -t                            : Test mode: inject unwanted tld and verify fault recovery
    -d                            : Debug
    -h                            : This help

EOF
}


#### PARSE ARGUMENTS
while getopts "a:c:s:ftdh" opt; do
	case $opt in
		a) action=$OPTARG;;
		c) tlds_arg=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		f) force_action="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

check_tlds_coherency() {
# checks whether current ipsets and iptables rules match ones in the config file
	new_verified_tlds="$(find_active_tlds)"
	unwanted_tlds="$(subtract_list_a_from_b "$config_tlds" "$new_verified_tlds")"
	tlds_difference="$(find_lists_difference "$new_verified_tlds" "$config_tlds")"
	echo "$unwanted_tlds"
	[ "$tlds_difference" == "" ] && return 0 || return 1
}

find_active_tlds() {
# checks current ipsets and iptables rules for geoblocker
# returns a list of active tlds (country codes)

	current_ipset_tlds="$(ipset list -n | grep "$suite_name" | grep -o '..$' | tr '\n' ' ' | awk '{$1=$1};1')"
	current_iprules_tlds="$(iptables -L | grep -oP "(?<=src /\* $suite_name\_).*?(?= \*/)" | tr '\n' ' ' | awk '{$1=$1};1')"

	tlds_intersection="$(find_lists_intersection "$current_ipset_tlds" "$current_iprules_tlds")"
	tlds_difference="$(find_lists_difference "$current_ipset_tlds" "$current_iprules_tlds")"
	echo "$tlds_intersection"
	[ "$tlds_difference" == "" ] && return 0 || return 1
}

restore_from_config() {
# restore tlds from the config file

	echo "Re-applying previous countries set: '$config_tlds'... "
	$run_command -o -a "remove" -c "$config_tlds $unwanted_tlds $tlds_to_change"
	$run_command -o -a "add" -c "$config_tlds"; rv=$?

	tlds_coherency="$(check_tlds_coherency)"; rv=$?
	if [ $rv -eq 0 ]; then
		echo "Successfully re-applied previous countries set."
	else
		echo "Failed to re-apply previous countries set." >&2
		# call the *backup script to initiate recovery from fault
		${suite_name}-backup -a restore; rv=$?

		check_tlds_coherency; rv1=$?; rv=$(( rv + rv1 ))
		if [ $rv -eq 0 ]; then
			echo "Successfully re-applied previous countries set."
		else
			die "$rv" "Failed to re-apply previous countries set. Consider fixing your firewall or your system."
		fi
	fi
}


#### VARIABLES

# set environment variable "nolog" to avoid daughter scripts writing errors
#	to syslog when encountering incorrect arguments from the user
#	nolog variable is checked in the sourced *common script
export nolog="true"

# get install_dir from the config file
install_dir="$(getconfig "Installdir")"; rv=$?

# convert input country codes (tlds) to lower case
tlds_arg="${tlds_arg,,}"

# remove duplicates etc
tlds_arg="$(sanitize_string "$tlds_arg")"

### Read current set of countries from the the config file into config_tlds
config_tlds="$(getconfig "Countries")"

action="${action,,}"

run_command="${install_dir}/${suite_name}-run"

# get datadir from the config file
datadir="$(getconfig "Datadir")"


#### CHECKS

# check for root
[ "$EUID" -ne 0 ] && die 1 "This needs to be run as root."

# check that the config file exists
[ ! -f "$conf_file" ] && die "Config file '$conf_file' doesn't exist! Run the installation script again."

## Check arguments for sanity

# check for valid action

[ -z "$action" ] && { usage; die 1 "Specify action with '-a <action>'!"; }

case "$action" in
	add) ;;
	remove) ;;
	schedule) ;;
	*) die 1 "Error: unsupported action '$action'." ;;
esac

[[ ("$action" == "add" || "$action" == "remove") && -z "$tlds_arg" ]] && \
	die 1 "Error: action '$action' requires to specify countries with '-c <tlds>'!"

[[ "$action" == "schedule" && ( -n "$tlds_arg" || -n "$force_action" ) ]] && \
	die 1 "Action '$action' only supports changing the cron schedule! Do not use it with any option except '-s' or '-d' !"

[ "$action" != "schedule" ] && [ -n "$cron_schedule" ] && {
	msg1="Error: the '-s <\"cron_schedule\">' option only works with the \"schedule\" action."
	msg2="To set up cron schedule, use '$me -a schedule -s <\"cron_schedule\">'"
	usage
	die "$msg1" "$msg2";
}


#### MAIN

debugprint "Countries in initial config: '$config_tlds'"

case "$action" in

	add)
		requested_planned_tlds="$(merge_lists "$config_tlds" "$tlds_arg")"
		debugprint "requested resulting tlds: '$requested_planned_tlds'"

		if [ -z "$force_action" ]; then
			# remove any entries already present in config_tlds from tlds_arg and assign to tlds_to_change
			tlds_to_change="$(find_lists_difference "$config_tlds" "$requested_planned_tlds")"

			# find which tlds were specified for addition but already exist
			wrong_tlds="$(find_lists_intersection "$tlds_arg" "$config_tlds")"

			[ "$wrong_tlds" != "" ] && echo "NOTE: countries '$wrong_tlds' have already been added." >&2
		else
			tlds_to_change="$tlds_arg"
		fi
		planned_tlds="$(merge_lists "$config_tlds" "$tlds_to_change")"
		debugprint "action: add, tlds_to_change: '$tlds_to_change'"
	;;

	remove)
		debugprint "requested tlds to remove: '$tlds_arg'"
		if [ -z "$force_action" ]; then
			# find duplicate-free intersection between config_tlds and tlds_arg
			tlds_to_change="$(find_lists_intersection "$config_tlds" "$tlds_arg")"
			# find which tlds were specified for removal but don't exist
			good_tlds="$(find_lists_intersection "$tlds_to_change" "$tlds_arg")"
			wrong_tlds="$(find_lists_difference "$tlds_arg" "$good_tlds")"
			[ "$wrong_tlds" != "" ] && echo "NOTE: countries '$wrong_tlds' have not been added, so can not remove." >&2

		else
			tlds_to_change="$tlds_arg"
		fi
		# remove any entries found in tlds_to_change from config_tlds and assign to planned_tlds
		planned_tlds="$(subtract_list_a_from_b "$tlds_to_change" "$config_tlds")"
	;;
esac


if [ "$action" != "add" ] && [ "$action" != "remove" ]; then
	debugprint "Skipping the *run script call because specified action was '$action'."
else

	if [ -z "$tlds_to_change" ] && [ -z "$force_action" ]; then
		config_tlds="$(getconfig "Countries")"
		echo "Countries in final config: '$config_tlds'."
		die 254 "Nothing to do, exiting."
	fi

	debugprint "planned tlds after '$action': '$planned_tlds'"

	# if planned_tlds list is empty
	if [ -z "$planned_tlds" ] && [ -z "$force_action" ]; then
		die 1 "Planned final countries list is empty! Disallowing this to prevent accidental lockout of a remote server."
	fi


	### Call the *run script
	$run_command -o -a "$action" -c "$tlds_to_change"; rv=$?

	# positive return code means apply failure or another permanent error, except for 254
	if [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
		echo "Error performing action '$action' for countries '$tlds_to_change'." >&2

		if [ "$config_tlds" = "" ]; then
			die 1 "Can not restore previous countries set because it is not found in the config file."
		fi

		restore_from_config
	fi

	new_verified_tlds="$(find_active_tlds)"
	failed_tlds="$(find_lists_difference "$new_verified_tlds" "$planned_tlds")"

	# if all 'add' actions failed
	if [ -z "$(find_lists_difference "$tlds_to_change" "$failed_tlds")" ]; then
		debugprint "failed_tlds: '$failed_tlds'"
		die 1 "All actions failed."
	fi

	if [ "$failed_tlds" != "" ]; then
		echo "Warning: failed to apply new rules for countries: $failed_tlds." >&2
	fi

	setconfig "Countries" "$new_verified_tlds"; rv=$?
	[ "$rv" -ne 0 ] && die 1 "Failed to write updated set of tlds '$new_verified_tlds' to config file '$conf_file'."

	config_tlds="$(getconfig "Countries")"
	debugprint "New tlds after updating config: '$config_tlds'"

####### Fault recovery test: inject unrequested tld
[ "$test" ] &&	$run_command -o -a "add" -c "ge"; rv=$?
#######


	# double-check coherency after applying new tlds
	unwanted_tlds="$(check_tlds_coherency)"; rv=$?
	if [ $rv -eq 0 ]; then
		debugprint "Successfully double-checked tlds coherency."
	else
		echo "Warning: actual firewall config differs from what it's supposed to be!"
		[ "$unwanted_tlds" != "" ] && echo "Found unwanted tlds: $unwanted_tlds"
		echo "Attempting to re-apply the rules." >&2
		tlds_to_change=""
		restore_from_config
	fi

	echo "Countries in final config: '$config_tlds'."
	echo
	echo "View iptables rules with 'sudo iptables -L'"
	echo
	## call the backup script
	debugprint "Calling the backup script"
	${suite_name}-backup -a backup
fi


### Cron jobs management

if [ "$action" != "schedule" ]; then
	debugprint "Skipping cron setup because action is not 'schedule'."
else

	# translate *manage arguments into *cronsetup arguments
	# can't send empty $cron_schedule argument because of getopts issues with empty arguments
	if [ "$cron_schedule" = "disable" ]; then
		cron_action="disable"
		cron_schedule="disable"
	else cron_action="apply"
	fi

	[ -z "$cron_schedule" ] && cron_schedule="disable"

	# check that countries list in config is not empty
	config_tlds="$(getconfig "Countries")"

	if [ -z "$config_tlds" ]; then
		die 1 "Error: Countries list in the config file is empty! No point in creating cron jobs."
	else
		${suite_name}-cronsetup -a "$cron_action" -s "$cron_schedule"
	fi
	echo
	echo "View current cron jobs with 'sudo crontab -l'"
fi

echo

debugexitmsg

exit 0
