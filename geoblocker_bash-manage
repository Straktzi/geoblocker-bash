#!/usr/bin/env bash

# geoblocker_bash-manage

# Provides an interface for the user (and for the -install script) to set up geoblocking.

# Supported actions: add, remove, schedule.

# 'geoblocker_bash-manage -a add|remove -c <country_code>' :
#     Adds or removes the specified country codes (tld's) to/from the config file.
#     Calls the -run script to fetch and apply the whitelists.
#     Creates a periodic cron job and a reboot job, unless ran with the -n (no persistence) option.
#     Cron jobs implement persistence and automatic list updates.
#     Accepts an optional custom cron schedule expression as an argument.
#     If schedule is not specified, uses schedule from the config file.

# 'geoblocker_bash-manage -a schedule -s <schedule_expression>' : changes the schedule for the periodic cron job.

me=$(basename "$0")
parent_script="$(ps -o args= $PPID | awk -v RS='/| ' '/^geoblocker/')"

# arguments sanitization
arguments=()
for arg in "$@"; do
	# trim single-quotes if any
	arg="${arg//\'}";
	# trim double-quotes if any
	arg="${arg//\"}"
	# trim leading and trailing whitespaces
	arg="$(awk '{$1=$1};1' <<< "$arg")"
	# add to array while discarding empty arguments
	[ -n "$arg" ] && arguments+=("$arg")
done
# replace arguments with sanitized ones
set -- "${arguments[@]}"

#### USAGE

usage() {
    cat <<EOF

$me
    Provides an interface for the user (and for the -install script) to set up geoblocking.
    Supported actions: add, remove, schedule.

WARNING: if removing a whitelist: Geoblocking will remain active after removal.
         If you remove your country's whitelist, you may lose remote access to your system.


    Usage: $me -a <add|remove|schedule> [-c "[tld] [tld] ... [tld]"] [-s "<sch_expression>"] [-n] [-p] [-d] [-h]

    Options:
        -a action               : action to perform: "add" or "remove" associated rules and cron jobs
                                     or "schedule" to change the cron schedule without changing iptables rules

        -c "tld(s)"             : tld / country codes. if passing multiple country codes, use double quotes
        -s "<sch_expression>"   : schedule expression for the periodic cron job, must be inside double quotes

        -n                      : No persistence (skip creating cron jobs)
        -p                      : No Drop: applies the config but skips setting INPUT chain default policy to DROP
                                     (continue to accept all connections)
        -d                      : Debug
        -h                      : This help

EOF
}

#### PARSE ARGUMENTS
while getopts "a:c:s:npdh" opt; do
	case $opt in
		a) action=$OPTARG;;
		c) tlds_arg=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		n) skip_cron=true;;
		p) nodrop="-p";;
		d) debug="-d";;
		h) usage; exit 0;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))


#### FUNCTIONS

debugprint() {
# prints a debug message
	[ "$debug" ] && echo -e "    Debug: $*"
}

echo ""

argsmsg="Started *manage with args: $(for arg in "${arguments[@]}"; do echo -n "'$arg'  "; done; echo)"
debugprint "\033[1;33m${argsmsg}\033[0m"

die() {
    if [ -n "$*" ]; then
        echo "" 1>&2
		# loop through arguments and print them to stderr and to the syslog
        for arg in "$@"; do
            echo "$arg" 1>&2
            logger -t "$me" "$arg"
        done
    fi
    [ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"
    echo "" 1>&2
    exit 1
}

getconfig() {
# reads a field named $1 from the config file $2
# outputs the resulting field
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	if [ -z "$fieldname" ] || [ -z "$configfile" ]; then return 1; fi
	field="$(grep "$fieldname=" "$configfile" | sed "s/.*$fieldname=//")"; rv=$?
	if [ -z "$field" ]; then
		echo ""
		rv=$((rv + 1))
	else
		echo "$field"
	fi
	return $rv
}

setconfig() {
# changes a field named $1 in the config file $2 to value $3
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	field="$3"
	if [ -z "$fieldname" ] || [ -z "$configfile" ]; then return 1; fi

	# remove corresponding config line
	grep -v "$fieldname=" "$configfile" > "${configfile}.temp"
	mv "${configfile}.temp" "$configfile"

	# add updated config line
	echo -e "$fieldname=$field" >> "$configfile"; rv=$?
	return $rv
}

find_lists_intersection() {
# finds duplicates-free intersection between fields in input strings $1 and $2,
#      and outputs the intersection as a string

	str1="$1"; str2="$2"
	result_str="$(comm -12 <(echo "$str1" | tr ' ' '\n' | sort -u) \
                        <(echo "$str2" | tr ' ' '\n' | sort -u) | tr '\n' ' ')"
	# trim leading, trailing, and extra in-between whitespaces
	result_str="$(awk '{$1=$1};1' <<< "$result_str")"
	echo "$result_str"
}

find_lists_difference() {
# finds fields that exist in lists $1 and $2 but not both and outputs the difference as a string

	str1="$1"; str2="$2"
	result_str="$(comm -3 <(echo "$str1" | tr ' ' '\n' | sort -u) \
                        <(echo "$str2" | tr ' ' '\n' | sort -u) | tr '\n' ' ')"
	# trim leading, trailing, and extra in-between whitespaces
	result_str="$(awk '{$1=$1};1' <<< "$result_str")"
	echo "$result_str"
}

remove_a_from_b() {
# removes all fields found in string $1 from string $2, outputs the result as a string

	str1="$1"; str2="$2"
	while read -r field_str; do
		str2="${str2//$field_str/}"
	done < <(echo "$str1" | tr ' ' '\n' )
	# trim leading, trailing, and extra in-between whitespaces
	str2="$(awk '{$1=$1};1' <<< "$str2")"
	echo "$str2"
}

#### VARIABLES

#convert country codes to lower case
tlds_arg="${tlds_arg,,}"

conf_dir="/etc/geoblocker_bash"
conf_file="${conf_dir}/geoblocker_bash.conf"

# get datadir from the config file
datadir="$(getconfig "Datadir" "$conf_file")"

# get install_dir from the config file
install_dir="$(getconfig "Installdir" "$conf_file")"

tlds_status_file="$datadir/tlds_status"

# get sleeptime (for reboot) from the config file
sleeptime="$(getconfig "RebootSleepTime" "$conf_file")"

run_command="${install_dir}/geoblocker_bash-run"


#### CHECKS

# TODO: test empty "action" etc

# check for root
if [ "$EUID" -ne 0 ]; then
  die "This needs to be run as root."
fi

# check if cron service is enabled
(systemctl is-enabled cron.service) > /dev/null; rv=$?
if [ $rv -ne 0 ]; then crondisabled="true"; fi


# Check the passed arguments for sanity

if [ -z "$action" ]; then
	usage
	die "Specify action with '-a <action>'!"
fi

if [ "$action" != "schedule" ] && [ -z "$tlds_arg" ]; then
	die "Error: action '$action' requires to specify countries with '-c <tlds>'!"
fi

if [ "$action" = "schedule" ] && [ -n "$tlds_arg" ]; then
	die "Error: action '$action' only supports changing the cron schedule! Do not use it with the '-c' option!"
fi

if [ "$action" = "schedule" ] && [ -n "$skip_cron" ]; then
	die "Error: action '$action' is incompatible with option '-n'!"
fi

if [ "$action" = "schedule" ] && [ -z "$cron_schedule" ]; then
	die "Error: action '$action' requires to provide cron schedule with option '-s'!"
fi

if [ "$action" = "schedule" ] && [ -n "$nodrop" ]; then
	die "Error: action '$action' is for setting the cron schedule only, don't use it with '-p'!"
fi

case "$action" in
	add) ;;
	remove) ;;
	schedule) ;;
	\?) die "Error: unsupported action '$action'.";;
esac

if [[ "$crondisabled" ]] && [ "$action" != "remove" ] && [ -z "$skip_cron" ]; then
	err1="Error: cron service seems to be disabled. Can not perform action '$action'"
	err2="On Debian and derivatives, enable the cron service with 'systemctl enable cron.service'. Exiting."
	die "$err1" "$err2"
fi

if [ -n "$cron_schedule" ] && [ -n "$skip_cron" ]; then
	die "Error: Conflicting arguments. Use either -s or -n but not both."
fi


if [ ! "$skip_cron" ]; then

	# if cron_schedule wasn't provided in args, use the schedule from the config file
	if [ -z "$cron_schedule" ]; then
		debugprint "Reading cron schedule from the config..."
		cron_schedule="$(getconfig "Cron_schedule" "$conf_file")"
		debugprint "Read cron schedule: $cron_schedule"
	fi


	# validate cron schedule
	debugprint "Validating cron schedule: '$cron_schedule'."
	validate_cron_schedule.sh -x "$cron_schedule" "$debug"; rv=$?
	if [ "$rv" -ne 0 ]; then
		die "Error validating cron schedule '$cron_schedule'. Exiting."
	else
		debugprint "Successfully validated cron schedule: '$cron_schedule'."
	fi
else
	debugprint "Skipping cron schedule validation."
fi


#### MAIN

### Read current set of countries from the the config file into config_tlds
config_tlds="$(getconfig "Countries" "$conf_file")"

debugprint "Countries in initial config: '$config_tlds'"

# re-create tlds_status_file
echo "" > "$tlds_status_file"

case "$action" in

	add)
		# merge $config_tlds with $tlds_arg while removing duplicates
		new_tlds="$(echo "$config_tlds $tlds_arg" | tr " " "\n" | sort -ibu |  tr "\n" " ")"
		# trim leading, trailing, and extra in-between whitespaces
		new_tlds="$(awk '{$1=$1};1' <<< "$new_tlds")"

		# remove any entries already found in config_tlds from tlds_arg and assign to tlds_to_change
		tlds_to_change="$(remove_a_from_b "$config_tlds" "$tlds_arg")"
		# find which tlds were specified for removal but don't exist

		wrong_tlds="$(find_lists_difference "$tlds_to_change" "$tlds_arg")"
		[ -n "$wrong_tlds" ] && echo "NOTE: countries '$wrong_tlds' have already been added." >&2
	;;
	remove)
		# find duplicate-free intersection between config_tlds and tlds_arg
		tlds_to_change="$(find_lists_intersection "$config_tlds" "$tlds_arg")"
		debugprint "tlds to remove: '$tlds_to_change'"

		# find which tlds were specified for removal but don't exist
		wrong_tlds="$(find_lists_difference "$tlds_to_change" "$tlds_arg")"
		[ -n "$wrong_tlds" ] && echo "NOTE: countries '$wrong_tlds' have not been added, so can not remove." >&2

		# remove any entries found in tlds_to_change from config_tlds and assign to new_tlds
		new_tlds="$(remove_a_from_b "$tlds_to_change" "$config_tlds")"
		# trim leading, trailing, and extra in-between whitespaces
		new_tlds="$(awk '{$1=$1};1' <<< "$new_tlds")"
	;;
esac

# TODO: Add checks for discrepancy between the config and actual existing ipsets and iptables rules

if [ "$action" = "schedule" ]; then
	debugprint "Note: Skipping the *run script call because specified action was 'schedule'."
else

	if [ -z "$tlds_to_change" ]; then
		die "Nothing to do, exiting."
	fi

	debugprint "planned tlds before '$action': '$new_tlds'"

	# if new_tlds list is empty
	if [ -z "$new_tlds" ]; then
		die "Planned final countries list is empty! If you really want to block evrything, do this manually. Exiting."
	fi


	### Call the *run script

	$run_command -o "$debug" "$nodrop" -a "$action" -c "$tlds_to_change"; rv=$?

	# 254 return code means fetch failure
	if [ $rv -eq 254 ]; then
		# read failed tlds from file
		failed_tlds="$(getconfig "FailedTLDs" "$tlds_status_file")"
		echo "Error performing action '$action' for countries '$failed_tlds'." >&2

	# positive return code means apply failure or another permanent error, except for 254
	elif [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
		echo "Error performing action '$action' for countries '$tlds_to_change'." >&2

		if [ -z "$config_tlds" ]; then
			die "Can not restore previous countries set because it is not found in the config file."
		fi

		# restore old countries set in the config file
		echo "Re-applying previous countries set: '$config_tlds'... "
		$run_command "$debug" "$nodrop" -a "update"; rv=$?
		if [ $rv -eq 0 ]; then
			msg="Successfully re-applied previous countries set."
			die "$msg"
		else
			echo "Failed to re-apply previous countries set." >&2
			# call the *backup script to initiate recovery from fault
			geoblocker_bash-backup -r "$debug"
			die ""
		fi
	fi

	if [ "$action" = "add" ]; then
			# read successfully applied tlds from the status file
			ok_tlds="$(getconfig "OkTLDs" "$tlds_status_file")"
			# merge the 2 lists while trimming leading, trailing, and extra in-between whitespaces
			new_tlds="$(awk '{$1=$1};1' <<< "$config_tlds $ok_tlds")"
	fi

	# if all actions failed
	if [ -z "$(find_lists_difference "$config_tlds" "$new_tlds")" ]; then
		die "All actions failed."
	fi

	setconfig "Countries" "$conf_file" "$new_tlds"; rv=$?
	[ "$rv" -ne 0 ] && die "Failed to write new set of tlds '$new_tlds' to config file '$conf_file'."

	config_tlds="$(getconfig "Countries" "$conf_file")"
	echo "Countries in final config: '$config_tlds'."
fi


### Cron jobs management

## Read current cron jobs into variable
	curr_cron_jobs="$(crontab -u root -l 2>/dev/null | grep "\"$run_command\"")"
	debugprint "Current cron jobs: $curr_cron_jobs"

## Remove current cron jobs
echo ""
echo "Removing cron jobs for geoblocker_bash..."
crontab -u root -l 2>/dev/null | grep -v "\"$run_command\"" | sudo crontab -u root -


# If action is "remove", don't assume that persistence is required
# Only create new cron jobs if prior cron jobs exist
if [ "$action" = "remove" ] && [ -z "$curr_cron_jobs" ]; then
	skip_cron="true"
fi


if [ ! "$skip_cron" ]; then

	# check that countries list in config is not empty
	config_tlds="$(getconfig "Countries" "$conf_file")"

	if [ -z "$config_tlds" ]; then
		die "Error: Countries list in the config file is empty! No point in creating cron jobs."
	else

		### Create cron jobs

		echo ""
		echo -n "Creating periodic cron job with schedule '$cron_schedule'... "
		echo -e "$(sudo crontab -u root -l 2>/dev/null)\n$cron_schedule \"$run_command\" $nodrop -a update &>/dev/null" | sudo crontab -u root -
		rv=$?

		if [ $rv -ne 0 ]; then
			die "Error running the crontab command."
		else
			echo "Ok."
			cron_line_result=$(crontab -u root -l 2>/dev/null |  grep  "\"$run_command\"")
			debugprint "Cron line: '$cron_line_result'"
		fi

		echo -n "Creating reboot cron job... "

		# using the -s switch for the *run script to skip fetching at reboot
		## otherwise if there was no internet connection at reboot time, *fetch would fail which would cause *run to fail,
		## so *apply wouldn't run, which would leave the system without geoblocking rules
		echo -e "$(sudo crontab -u root -l 2>/dev/null)\n@reboot sleep $sleeptime && \"$run_command\" $nodrop  -a update -s &>/dev/null" | \
                	sudo crontab -u root -; rv=$?

		if [ $rv -ne 0 ]; then
			die "Error running the crontab command."
		else
			echo "Ok."
			cron_line_result="$(crontab -u root -l 2>/dev/null |  grep "reboot sleep .* && \"$run_command\"")"
			debugprint "Reboot cron line: '$cron_line_result'"
		fi

		# save cron schedule to the config file
		setconfig "Cron_schedule" "$conf_file" "$cron_schedule"
	fi
else
	echo "NOTE: Skipping cron jobs creation."
fi
echo ""

# call the backup script to create a known-good backup of config, ipsets and iptables state
geoblocker_bash-backup "$debug" -b


echo ""
echo "View iptables rules with 'sudo iptables -L'"
echo "View cron jobs with 'sudo crontab -l'"

[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"

exit 0
