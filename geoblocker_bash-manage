#!/usr/bin/env bash

# geoblocker_bash-manage

# Allows to add or remove a whitelist for specified countries to/from geoblocking rules
#       and creates or updates associated cron jobs

me=$(basename "$0")
parent_script="$(ps -o args= $PPID | awk -v RS='/| ' '/^geoblocker/')"
args="$@"

#### USAGE

usage() {
    cat <<EOF

$me
    Allows to add or delete whitelists for specified countries to/from geoblocking rules
        and creates or updates associated cron jobs.

WARNING if removing a whitelist: Geoblocking will remain active after removal.
        If you remove your country's whitelist, you may lose remote access to your system.


    Usage: $me -c <"tld [tld] ... [tld]"> -a <add|remove> [-s <"schedule">] [-n] [-p] [-d] [-h]

    Options:
        -c <"tld(s)">   : tld / country codes. if passing multiple country codes, use double quotes
        -a <action>     : action to perform: "add" or "remove" associated rules and cron jobs
        -s <"schedule"> : schedule expression for the cron job, must be inside double quotes

        -n              : No persistence (skip creating cron jobs)
        -p              : No Drop: applies the config but skips setting INPUT chain default policy to DROP
                                   (continue to accept all connections)
        -d              : Debug
        -h              : This help

EOF
}

#### PARSE ARGUMENTS
while getopts "c:a:s:npdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		a) action=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		n) skip_cron=true;;
		p) nodrop="-p";;
		d) debug="-d";;
		h) usage; exit 0;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))


#### FUNCTIONS

debugprint() {
# prints a debug message
	[ "$debug" ] && echo -e "    Debug: $@"
}

echo ""
debugprint "\033[1;33mStarted *manage with args: '$args'\033[0m"

die() {
[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"
exit 1
}

get_script_dir() {
	SOURCE=${BASH_SOURCE[0]}
	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
		SOURCE=$(readlink "$SOURCE")
		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
		# if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	done
	DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
	echo "$DIR"
}

getconfig() {
# reads a field named $1 from the config file $2
# outputs the resulting field
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	if [ -z "$fieldname" ] || [ -z "$configfile" ]; then return 1; fi
	read -r field < <(grep "$fieldname=" "$configfile" | sed "s/.*$fieldname=//"); rv=$?
	if [ -z "$field" ]; then
		echo ""
		rv=$((rv + 1))
	else
		echo "$field"
	fi
	return $rv
}

setconfig() {
# changes a field named $1 in the config file $2 to value $3
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	field="$3"
	if [ -z "$fieldname" ] || [ -z "$configfile" ] || [ -z "$field" ]; then return 1; fi

	# remove corresponding config line
	cat "$configfile" | grep -v "$fieldname=" > "${configfile}.temp"
	mv "${configfile}.temp" "$configfile"

	# add updated config line
	echo -e "$fieldname=$field" >> "$configfile"; rv=$?
	return $rv
}

#### VARIABLES

#convert country codes to lower case
tlds="$(echo ${tlds,,})"

# TODO: implement config saving in the *install script

conf_dir="/etc/geoblocker_bash"
conf_file="${conf_dir}/geoblocker_bash.conf"

# get datadir from the config file
read -r datadir < <(getconfig "Datadir" "$conf_file")

preinstall_policies_file="$datadir/preinstall_policies.bak"
knowngood_file="$datadir/iptables_knowngood.bak"
whitelist_dir="$datadir/ip_lists"
failed_tlds_file="$datadir/FailedTLDs"

# get sleeptime (for reboot) from the config file
read -r sleeptime < <(getconfig "RebootSleepTime" "$conf_file")

# get the script path
read -r scriptdir < <(get_script_dir)

run_command="${scriptdir}/geoblocker_bash-run"


#### CHECKS

if [ -z "$tlds" ]; then
	usage
	echo "Specify countries with \"-c <tlds>\"!"
	echo ""
	die
fi

case "$action" in
	add) ;;
	remove) ;;
	\?) usage; echo "Unsupported action \"$action\"."; die;;
esac

# TODO: test empty "action" etc

if [ -z "$action" ]; then
	usage
	echo "Specify action with \"-a <action>\"!"
	echo ""
	die
fi

# check for root
if [ "$EUID" -ne 0 ]
  then echo "This needs to be run as root."
  die
fi

# check if cron service is enabled
(systemctl is-enabled cron.service) > /dev/null; rv=$?
if [ $rv -ne 0 ]; then crondisabled="true"; fi

if [[ "$crondisabled" ]] && [ "$action" = "add" ]; then
	echo "Error: cron service seems to be disabled. Can not perform action \"$action\""
	echo "On Debian and derivatives, enable the cron service with \"systemctl enable cron.service\". Exiting." >&2
	echo ""
	die
fi

# cd into script directory
# exit in case "cd" fails
cd "$scriptdir"; rv=$?
if [ -z "$scriptdir" ] || [ "$rv" -ne 0 ]; then echo "Error: could not change directory to \"$scriptdir\". Exiting."; die; fi

if [ ! "$skip_cron" ]; then

	# if cron_schedule wasn't provided in args, use the default schedule from the config file
	if [ -z "$cron_schedule" ]; then
		read -r cron_schedule < <(getconfig "Default_schedule" "$conf_file")
	fi

	# validate cron schedule
	debugprint "Validating cron schedule: '$cron_schedule'."
	read -r cron_schedule < <(validate_cron_schedule.sh $debug -x "$cron_schedule"); rv=$?
	if [ $rv -ne 0 ]; then
		echo "Error validating cron schedule '$cron_schedule'. Exiting." >&2
		echo ""
		die
	else
		debugprint "Successfully validated cron schedule: '$cron_schedule'."
	fi
else
	debugprint "Skipping cron schedule validation."
fi


#### MAIN

### Read current set of countries from the the config file into array config_tlds
config_tlds=( $(getconfig "Countries" "$conf_file") )

# Get new set of countries from the argument into array arg_tlds
arg_tlds=( $(echo "$tlds") )

case "$action" in
# some fairly ugly array-to-string-and-back conversions but appears to be the most straightforward way to do this

	add)
		# merge config_tlds and arg_tlds arrays into new_tlds array while removing duplicates
		new_tlds=( $(printf '%s\n'  "${config_tlds[@]}" "${arg_tlds[@]}" | sort -ibu) )

		# convert to string
		tlds_to_change_str="${arg_tlds[@]}"

		# tlds_to_change should contain countries that are not already in config_tlds
		# compare $item with every element of tlds_to_change and remove exact matches in tlds_to_change
		for item in "${config_tlds[@]}"; do
			tlds_to_change_str="${tlds_to_change_str//$item/}"
		done
		# convert to array while removing duplicates
		tlds_to_change=( $(echo "$tlds_to_change_str" | sort -ibu) )
		if [ -z "$(echo ${tlds_to_change[@]})" ]; then
			echo "Error: can not add countries \"${arg_tlds[@]}\" because they have already been added."
			echo ""
			die
		fi
	;;
	remove)
		# convert to string
		new_tlds_str="${config_tlds[@]}"

		# compare $item with every element of new_tlds_str and remove exact matches in new_tlds_str
		for item in "${arg_tlds[@]}"; do
			new_tlds_str="${new_tlds_str//$item/}"
		done

		# convert to array while removing duplicates
		new_tlds=( $(echo "$new_tlds_str" | sort -ibu) )

		# find duplicate-free intersection between {config_tlds[@]} and {arg_tlds[@]} so later we know what countries to remove
		read -r -d '' -a tlds_to_change < <(join <(printf %s\\n "${config_tlds[@]}" | sort -u) \
                          <(printf %s\\n "${arg_tlds[@]}" | sort -u))

		if [ -z "$(echo ${tlds_to_change[@]})" ]; then
			echo "Error: can not remove countries \"${arg_tlds[@]}\" because they have not been added."
			echo ""
			die
		fi
	;;
esac

debugprint "tlds to change: ${tlds_to_change[@]}"

setconfig "Countries" "$conf_file" "$(echo ${new_tlds[@]})"; rv=$?
if [ $rv -ne 0 ]; then
	echo ""
	echo "Error writing new config for countries \"${new_tlds[@]}\" to file \"$conf_file\"."
	die
fi
debugprint "Countries in updated config: $(getconfig Countries $conf_file)"


### Call the *run script

# TODO: add -r option to *apply for rules removal

echo $run_command $debug $nodrop -a "$action" -c "'$(echo ${tlds_to_change[@]})'" | bash; rv=$?

# 254 return code means fetch failure
if [ $rv -eq 254 ]; then
	echo ""
	echo "Error performing action \"$action\" for countries \"${tlds_to_change[@]}\"."
	echo "Removing failed tld's from config..."

	# read failed tlds from file into array failed_tlds
	failed_tlds=( $(getconfig "FailedTLDs" "$failed_tlds_file") )

	# get duplicate-free intersection between ${tlds_to_change[@]} and ${failed_tlds[@]}
	read -r -d '' -a tlds_to_remove < <(join <(printf %s\\n "${tlds_to_change[@]}" | sort -u) \
                   <(printf %s\\n "${failed_tlds[@]}" | sort -u))

	# only remove newly-added tlds that failed to fetch
	if [ -n "$(echo ${tlds_to_remove[@]})" ]; then
		# remove only the intersection tlds from config

		#convert array to string
		new_tlds_str="${new_tlds[@]}"

		# compare $item with every element of new_tlds_str and remove exact matches in new_tlds_str
		for item in "${tlds_to_remove[@]}"; do
			new_tlds_str="${new_tlds_str//$item/}"
		done

		# convert to array while removing duplicates
		new_tlds=( $(echo "$new_tlds_str" | sort -ibu) )

		# write new tlds list to config file
		setconfig "Countries" "$conf_file" "${new_tlds[@]}"; rv=$?
	fi

# positive return code means apply failure or another permanent error, except for 254
elif [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
	echo ""
	echo "Error performing action \"$action\" for countries \"${tlds_to_change[@]}\"."

	if [ -z "$(echo ${config_tlds[@]})" ]; then
		echo "Can not restore previous countries set because it is not found in the config file."
		die
	fi

	# restore old countries set in the config file
	echo -n "Restoring previous countries set: \"${config_tlds[@]}\"..."
	setconfig "Countries" "$conf_file" "${config_tlds[@]}"
	echo $run_command $debug $nodrop -a "update" | bash; rv=$?
	if [ $rv -eq 0 ]; then
		echo "Ok."
	else
		echo "Failed."
	fi
	die

elif [ $rv -eq 0 ]; then
	debugprint "Successfully performed action \"$action\" for countries \"${tlds_to_change[@]}\"."
fi


### Cron jobs management

## Read current cron jobs into variable
	read -r curr_cron_jobs < <(crontab -u root -l 2>/dev/null | grep "\"$run_command\"")
	debugprint "Current cron jobs: $curr_cron_jobs"

## Remove current cron jobs
echo ""
echo "Removing cron jobs for geoblocker_bash..."
crontab -u root -l 2>/dev/null | grep -v "\"$run_command\"" | sudo crontab -u root -


# If action is "remove", don't assume that persistence is required
# Only create new cron jobs if prior cron jobs exist
if [ "$action" = "remove" ] && [ -z "$curr_cron_jobs" ]; then
	skip_cron="true"
fi

new_tlds_str="$(echo ${new_tlds[@]})"

# If new countries list is empty, skip creating cron jobs
if [ -z "$new_tlds_str" ]; then
	skip_cron="true"
	debugprint "NOTE: New countries list is empty."
fi


if [ ! "$skip_cron" ]; then

	### Create cron jobs

	echo -n "Creating periodic cron job... "
	debugprint "applying cron line: $cron_schedule \"$run_command\" $nodrop -a update &>/dev/null"
	echo -e "$(sudo crontab -u root -l 2>/dev/null)\n$cron_schedule \"$run_command\" $nodrop -a update &>/dev/null" | sudo crontab -u root -
	rv=$?

	if [ $rv -ne 0 ]; then
		echo "Error running crontab command." >&2
		echo ""
		die
	else
		echo "Ok."
		cron_line_result=$(crontab -u root -l 2>/dev/null |  grep  "\"$run_command\"")
		debugprint "Cron line: \"$cron_line_result\""
	fi

	echo -n "Creating reboot cron job... "

	# using the -s switch for the *run script to skip fetching at reboot
	## otherwise if there was no internet connection at reboot time, *fetch would fail which would cause *run to fail,
	## so *apply wouldn't run, which would leave the system without geoblocking rules
	echo -e "$(sudo crontab -u root -l 2>/dev/null)\n@reboot sleep $sleeptime && \"$run_command\" $nodrop  -a update -s &>/dev/null" | \
                sudo crontab -u root -; rv=$?

	if [ $rv -ne 0 ]; then
		echo "Error running crontab command." >&2
		echo ""
		die
	else
		echo "Ok."
		cron_line_result=$(crontab -u root -l 2>/dev/null |  grep "reboot sleep .* && \"$run_command\"")
		debugprint "Reboot cron line: \"$cron_line_result\""
		echo ""
		echo "View cron jobs with \"sudo crontab -l\""
	fi
else
	echo "NOTE: Skipping cron jobs creation."
fi

echo ""
echo "View iptables rules with \"sudo iptables -L\""
echo ""

[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"

exit 0
