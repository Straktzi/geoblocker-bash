#!/usr/bin/env bash

# geoblocker-bash-install

# Installer for geoip blocking suite of bash scripts
# Must be run as root

# Requires the following additional scripts (included in the distribution):
# geoblocker-bash-apply, geoblockder_bash-backup, geoblocker-bash-common, geoblocker-bash-cronsetup,
# geoblocker-bash-fetch, geoblocker-bash-manage, geoblocker-bash-run, geoblocker-bash-uninstall,
# geoblocker-bash-reset, validate_cron_schedule.sh, check_ip_in_ripe.sh


#### Initial setup

me=$(basename "$0")

# check for root
[ "$EUID" -ne 0 ] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { echo "$me: Error: Couldn't cd into '$script_dir'." >&2; exit 1; }

source "$script_dir/${suite_name}-common" || { echo "$me: Error: Can't source '${suite_name}-common'." >&2; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {

    cat <<EOF

$me
Installer for geoip blocking suite of bash scripts.
Must be run as root.

This script:
1) Requires to specify countries (TLD's) to include in the whitelist/blacklist
2) Requires to specify whitelist or blacklist mode for installation with the '-m' option
3) Accepts a custom cron schedule expression as an argument. Default cron schedule is "0 4 * * *" - at 4:00 [am] every day.
4) Creates system folder structure for scripts, config and data.
5) Copies all scripts included in the suite to /usr/local/bin.
6) Creates backup of pre-install policies for INPUT and FORWARD iptables chains.
7) Calls the *manage script to set up geoblocker and then call the -fetch and -apply scripts.
8) If an error occurs during installation, calls the uninstall script to revert any changes made to the system.

Usage: $me -c <"tld [tld] ... [tld]"> -m <whitelist|blacklist> [-s <"sch_expression"|disable>] [-e] [-n] [-p] [-d] [-h]

Core Options:
    -c <"tld(s)">                  : tld / country codes to fetch and apply the iplists for.
                                           (if passing multiple country codes, use double quotes)
    -m <whitelist|blacklist>       : firewall mode to install: whitelist or blacklist
                                           (to change mode after installation, run the *install script again)
    -s <"sch_expression"|disable>  : schedule expression for the periodic cron job implementing auto-updates of the ip lists,
                                           must be inside double quotes
                                           default is "0 4 * * *" (at 4:00 [am] every day)
                                     "disable" will *skip* creating the autoupdate cron job so there will be no automatic updates of the ip lists

Extra Options:
    -e                             : Enable Emergency Deactivation. When enabled, if a severe error is encountered in operation,
                                            geoblocking will be automatically deactivated until the problem is manually fixed.
                                            Disabled by default.
    -n                             : No persistence. Will *skip* creating the cron job which is required for geoblocking to work upon reboot.
    -p                             : No Drop: installs the script and configures the firewall but in the whitelist mode,
                                           skips setting INPUT chain default policy to DROP
                                           (everything will be installed and configured but geoblocking won't be enabled)
                                           (does not affect blacklist functionality)
    -d                             : Debug
    -h                             : This help

EOF
}

#### PARSE ARGUMENTS

while getopts ":c:m:s:enpdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		m) list_type=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		e) emergency_deactivation="true";;
		n) no_persistence="true";;
		p) nodrop="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		\?) usage; die "Error: Unknown option: '$OPTARG'." ;;
	esac
done
shift $((OPTIND -1))

[[ "$*" != "" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them in double quotation marks."
	die -nolog "$err1" "$err2"
}

echo

# get debugmode variable from either the args or environment variable
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

install_failed() {
	echo "$*" >&2
	echo -e "\nInstallation failed." >&2
	echo "Uninstalling ${suite_name}..." >&2
	bash ${suite_name}-uninstall
	exit 1
}

check_file_exists() {
if [ ! -f "$1" ]; then
	die "Error: Can not find the file '$1'."
fi
}

copyscript() {
	scriptfile="$1"; destination="$2"
	cp "$scriptfile" "$destination" || install_failed "Error copying script '$scriptfile' to '$destination'."
	chmod a+x "${install_dir}/$scriptfile" || install_failed "Error: failed to set 'a+x' permissions for file '${install_dir}/$scriptfile'."
}


#### VARIABLES

# convert input country codes (tlds) to upper case
tlds_arg="${tlds_arg^^}"

# set environment variable "nolog" to avoid daughter scripts writing errors
#	to syslog when encountering incorrect arguments from the user
export nolog="true"

# set environment variable "manualmode" to signal to daughter scripts that user interaction is possible
export manualmode="true"

export in_install="true"

install_dir="/usr/local/bin"
datadir="/var/lib/${suite_name}"
preinstall_policies_file="${datadir}/preinstall_policies.bak"
knowngood_file="${datadir}/iptables_knowngood.bak"
iplist_dir="${datadir}/ip_lists"

default_schedule="0 4 * * *"
cron_schedule="${cron_schedule:-$default_schedule}"
sleeptime="30"

if [ -n "$list_type" ]; then
	# convert to lower case
	list_type="${list_type,,}"

	# set global variable
	export list_type="$list_type"
fi

#### CHECKS

if [ -z "$tlds" ]; then
	usage
	die "Specify countries with '-c <tlds>'!"
fi

if [ -z "$list_type" ]; then
	usage
	die "Specify firewall mode with '-m whitelist' or '-m blacklist'!"
fi

[[ "$list_type" != "whitelist" && "$list_type" != "blacklist" ]] &&  die "Error: Unrecognized list type '$list_type'! Use either 'whitelist' or 'blacklist'!"

# check for systemd
if [ "$(! ps -p 1 -o comm=)" != "systemd" ]; then
	die "Error: systemd is required but this sytem does not appear to be running systemd."
fi

# check for awk
if ! command -v awk &> /dev/null; then
	die "Error: Cannot find awk. Install it with 'sudo apt install gawk' or similar."
fi

# check for grep
if ! command -v grep &> /dev/null; then
	die "Error: Cannot find grep. Install it with 'sudo apt install grep' or similar."
fi

# check for curl
command -v "curl" &> /dev/null && curl_exists="true"

# check for wget
command -v "wget" &> /dev/null && wget_exists="true"

[[ ! "$curl_exists" && ! "$wget_exists" ]] && die "Error: Neither curl nor wget found."

# Check for ipset
if ! command -v "ipset" &> /dev/null; then
	die "Error: Can not find 'ipset'. Install it with 'apt install ipset' or similar."
fi

# Check for iptables-save
if ! command -v "iptables-save" &> /dev/null; then
	die "Error: Can not find 'iptables-save'."
fi

# Check for iptables-restore
if ! command -v "iptables-restore" &> /dev/null; then
	die "Error: Can not find 'iptables-restore'."
fi

# check for jq
if ! command -v jq &> /dev/null; then
	die "Error: Can not find 'jq'. Install it with 'apt install jq' or similar."
fi

# check for bc
if ! command -v bc &> /dev/null; then
	die "Error: Can not find the 'bc' utility. Install it with 'apt install bc' or similar."
fi


check_file_exists "${suite_name}-fetch"
check_file_exists "${suite_name}-common"
check_file_exists "${suite_name}-apply"
check_file_exists "${suite_name}-run"
check_file_exists "${suite_name}-manage"
check_file_exists "${suite_name}-cronsetup"
check_file_exists "${suite_name}-backup"
check_file_exists "${suite_name}-uninstall"
check_file_exists "${suite_name}-reset"
check_file_exists "validate_cron_schedule.sh"
check_file_exists "check_ip_in_ripe.sh"


#### MAIN

# Create the directory for config and, if required, parent directories
mkdir -p "$conf_dir"

# write initial config to the config file
echo -n "Setting initial config... "

setconfig "Countries=" "ListType=$list_type" "Installdir=$install_dir" "Datadir=$datadir" "CronSchedule=$cron_schedule" "DefaultSchedule=$defualt_schedule" \
	"RebootSleep=$sleeptime" "Backup_script=$backup_script" "EmergencyDeactivation=$emergency_deactivation" \
	"NoPersistence=$no_persistence" "NoDrop=$nodrop"; rv=$?

if [ "$rv" -ne 0 ]; then
	echo "Failed." >&2
	install_failed "Error writing initial config to the config file."
else echo "Ok."
fi

# Create the directory for downloaded lists and, if required, parent directories
mkdir -p "$iplist_dir"


## Create a backup file for known-good iptables state

echo -n "Creating file for backup of iptables state..."

# if a backup file already exists, continue installing but skip overwriting the backup file
if [ -f "$knowngood_file" ]; then
	echo "Backup file already exists, skipping."
else
	touch "$knowngood_file"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Error." >&2
		install_failed
	fi
	echo "Ok."
fi


## run the *reset script to make sure no previous firewall rules and cron jobs exist
bash ${suite_name}-reset


## Copy scripts to $install_dir

# if we are running from $install_dir, assume that all other necessary scripts have already been installed, skip copying
if [ "$script_dir" != "$install_dir" ]; then
	echo -n "Copying scripts to $install_dir... "
	copyscript "${suite_name}-common" "${install_dir}/"
	copyscript "${suite_name}-fetch" "${install_dir}/"
	copyscript "${suite_name}-apply" "${install_dir}/"
	copyscript "${suite_name}-run" "${install_dir}/"
	copyscript "${suite_name}-manage" "${install_dir}/"
	copyscript "${suite_name}-cronsetup" "${install_dir}/"
	copyscript "${suite_name}-backup" "${install_dir}/"
	copyscript "${suite_name}-uninstall" "${install_dir}/"
	copyscript "${suite_name}-reset" "${install_dir}/"
	copyscript "validate_cron_schedule.sh" "${install_dir}/"
	copyscript "check_ip_in_ripe.sh" "${install_dir}/"
	echo "Ok."
fi

## Create a symlink from ${suite_name}-manage to ${suite_name}
unlink "${install_dir}/${suite_name}" &> /dev/null
ln -s "${install_dir}/${suite_name}-manage" "${install_dir}/${suite_name}" ||
	install_failed "Failed to create symlink from ${suite_name}-manage to ${suite_name}"


### Back up pre-install policies for INPUT and FORWARD chains

echo -n "Creating backup of current INPUT and FORWARD iptables chains policies... "

# if a backup file already exists, continue installing but skip overwriting the backup file
if [ -f "$preinstall_policies_file" ]; then
	echo "Backup file already exists, skipping creation of iptables policies backup." >&2
else
	preinstall_input_policy=$(iptables -nL | grep "Chain INPUT" | awk -F'policy |)' '{print $2}')
	preinstall_forward_policy=$(iptables -nL | grep "Chain FORWARD" | awk -F'policy |)' '{print $2}')
	if [ -z "$preinstall_input_policy" ] || [ -z "$preinstall_forward_policy" ]; then
		install_failed "Error: failed to determine current iptables policies."
	fi
	touch "$preinstall_policies_file" || install_failed "Error: failed to create pre-install policies backup file."

	echo "INPUT $preinstall_input_policy" >> "$preinstall_policies_file"
	echo "FORWARD $preinstall_forward_policy" >> "$preinstall_policies_file"
	echo "Ok."
	debugprint "Pre-install policies:   INPUT: $preinstall_input_policy, FORWARD: $preinstall_forward_policy"
fi

# cd into the install directory
# exit in case "cd" fails
[ -n "$install_dir" ] && cd "$install_dir" || install_failed "Error: Couldn't cd into '$install_dir'."


### Add iplist(s) for $tlds to managed iplists, then fetch and apply the iplist(s)
${suite_name}-manage add -f -c "$tlds"; rv=$?

# the *manage script exits with return value 254 if requested country is already included in the config
if [ $rv -ne 0 ] && [ $rv -ne 254 ]; then
	install_failed "Failed to create and apply the iplist."
fi

if [[ ! "$no_persistence" && "$cron_schedule" != "disable" ]]; then
	### Set up cron jobs
	${suite_name}-manage schedule -s "$cron_schedule"; rv=$?

	if [ $rv -ne 0 ]; then
		install_failed "Error: failed to set up cron jobs."
	fi
else
	echo -e "Warning: Installed with no persistence and no autoupdate functionality.\n"
fi

echo -e "View current geoblocking status with 'sudo ${suite_name} status'.\n"

echo
echo "Install done."

echo

unset nolog
unset debugmode
unset manualmode
unset list_type
unset in_install

exit 0
