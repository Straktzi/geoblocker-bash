#!/usr/bin/env bash

# geoblocker-bash-manage

# Provides an interface to configure geoblocking.

#### Initial setup

me=$(basename "$0")

# check for root
[[ "$EUID" -ne 0 ]] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[[ -n "$script_dir" ]] && cd "$script_dir" || { echo "$me: Error: Couldn't cd into '$script_dir'." >&2; exit 1; }

source "$script_dir/${suite_name}-common" || { echo "$me: Error: Can't source ${suite_name}-common." >&2; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script


# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"

#### USAGE

usage() {
    cat <<EOF

$me
    Provides an interface to configure geoblocking.

Usage: $me <action> [-c "[tld] [tld] ... [tld]"] [-s <"sch_expression"|disable>] [-f] [-t] [-d] [-h]

Actions:
    add|remove                   : add or remove TLDs (country codes) to/from geoblocking rules
    schedule                     : change the cron schedule (has no effect on iptables rules)
    status                       : check on the current status of geoblocking

Options:
    -c "tld(s)"                   : tld / country codes. if passing multiple country codes, use double quotes.
    -s <"sch_expression"|disable> : schedule expression for the periodic cron job implementing auto-updates of the ip lists,
                                            must be inside double quotes.
                                            default schedule is "0 4 * * *" (at 4:00 [am] every day)
                                        disable: *skip* creating the cron job which is required for automatic updates of the ip list

    -f                            : Force the action even if it doesn't make sense or may cause remote server lockout.
    -t                            : Test mode: inject unexpected tld and verify fault recovery
    -d                            : Debug
    -h                            : This help

EOF
}


#### PARSE ARGUMENTS

# 1st argument should be the requested action
action="$1"
shift 1

# check for valid action
case "$action" in
	add | remove | schedule | status ) ;;
	* ) usage; err1="Error: Unrecognized action: '$action'."; err2="Specify action in the 1st argument!"; die -nolog "$err1" "$err2" ;;
esac

# process the rest of the arguments
while getopts ":c:s:ftdh" opt; do
	case $opt in
		c) tlds_arg=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		f) force_action="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		t) testmode=true;;
		\?) usage; echo "Error: Unknown option: '-$OPTARG'." >&2; exit 1;;
	esac
done
shift $((OPTIND -1))

# check if there are unprocessed arguments
[[ -n "$*" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them in double quotation marks."
	die -nolog "$err1" "$err2"
}

echo

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"
export testmode="$testmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

report_status() {
	case "$list_type" in
		whitelist) expected_policy="DROP"; expected_rule_type="ACCEPT"  ;;
		blacklist) expected_policy="ACCEPT"; expected_rule_type="DROP" ;;
		*) die "Error: unrecognized list type '$list_type'!"
	esac

	echo -e "\n${yellow}Geoblocking status report:${no_color}"

	echo -e "\nGeoblocking mode: ${yellow}${list_type}${no_color}.\n"

	input_policy=$(iptables -nL | grep "Chain INPUT" | awk -F'policy |)' '{print $2}')
	forward_policy=$(iptables -nL | grep "Chain FORWARD" | awk -F'policy |)' '{print $2}')

	if [[ -z "$input_policy" || -z "$forward_policy" ]]; then
		die "Error: failed to determine current policies for INPUT and FORWARD chains."
	fi

	# check ipsets and iptables rules for active tlds
	active_tlds="$(find_active_tlds)"; rv=$?
	[[ -z "$active_tlds" ]] && echo -e "${red}Warning${no_color}: no firewall rules found for any country codes!" || \
		echo -e "$list_type is configured for country codes: '${yellow}$active_tlds${no_color}'.\n"

	check_tlds_coherency; rv=$?
	if [[ "$rv" -ne 0 ]]; then
		echo -e "${red}Error${no_color}: discrepancy detected between the config file and iptables rules!\n" >&2
		[[ "$ipsets_incoherent" ]] && \
			echo -e "${purple}Warning:${no_color} discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!\n" >&2
	else
		echo -e "Country codes in the firewall rules ${green}match${no_color} the config.\n"
	fi

	# report INPUT and FORWARD chain policies
	[[ "$input_policy" = "$expected_policy" ]] && input_policy_colored="${green}${input_policy}${no_color}" || \
		input_policy_colored="${red}${input_policy}${no_color}"
	[[ "$forward_policy" = "$expected_policy" || "$forward_policy" = "DROP" ]] && forward_policy_colored="${green}${forward_policy}${no_color}" || \
		forward_policy_colored="${red}${forward_policy}${no_color}"
	echo -e "Active ${yellow}iptables policies${no_color}: \nINPUT chain: $input_policy_colored, FORWARD chain: $forward_policy_colored\n"


	# check INPUT chain default policy compatibility with list_type
	[[ "$input_policy" != "$expected_policy" ]] && {
				echo -e "${purple}WARNING${no_color}: $list_type functionality requires INPUT chain policy to be '$expected_policy' but it is '$input_policy'."
				echo -e "${red}$list_type is not functioning${no_color}.";
				} || echo -e "INPUT chain policy ${green}is compatible${no_color} with $list_type."

	# check FORWARD chain default policy compatibility with list_type
	[[ "$forward_policy" != "$expected_policy" && "$forward_policy" != "DROP" ]] && {
				echo -e "${purple}WARNING${no_color}: $list_type functionality recommends FORWARD chain policy to be '$expected_policy' but it is '$forward_policy'."
				} || echo -e "FORWARD chain policy ${green}is compatible${no_color} with $list_type."


	# for a whitelist, report global iptables rules (irrelevant for blacklist)
	if [[ "$list_type" = "whitelist" ]]; then
		echo -e "\n${yellow}Global iptables rules${no_color} for $suite_name:"
		global_rules="$(iptables-save | grep "${suite_name}_global")"
		[[ -z "$global_rules" ]] && echo -e "None.\n" || echo -e "${global_rules}\n"
	fi

	# report specific rules for the active geoblocking mode
	echo -e "\n${yellow}$list_type iptables rules${no_color} for $suite_name:"
	geoblocking_rules="$(iptables -L -v | grep "match-set ${suite_name}" | grep "$expected_rule_type")"
	[[ -z "$geoblocking_rules" ]] && echo -e "${red}None.${no_color}\n" || echo -e "$geoblocking_rules\n"

	# check if cron service is enabled
	(systemctl is-enabled cron.service) > /dev/null || crondisabled="true"
	if [[ -n "$crondisabled" ]]; then
		echo -e "${purple}WARNING${no_color}: cron service appears to be disabled. Both persistence across reboots and autoupdates will likely not work.\n"
	else
		echo -e "Cron system service is ${green}enabled${no_color}.\n"

		# check cron jobs
		persistence_job="$(crontab -u root -l 2>/dev/null | grep "${suite_name}-persistence")"
		[[ -n "$persistence_job" ]] && echo -e "${green}Persistence cron job is active${no_color}.\n" || \
			echo -e "${purple}WARNING${no_color}: Persistence cron job is ${red}missing${no_color}. Geoblocking will not work after reboot.\n"

		autoupdate_job="$(crontab -u root -l 2>/dev/null | grep "${suite_name}-autoupdate")"
		if [[ -n "$autoupdate_job" ]]; then
			echo -e "${green}Autoupdate cron job is active.${no_color}\n"
			update_schedule="$(echo "$autoupdate_job" | cut -f1 -d\")"
			if [[ -n "$update_schedule" && "$update_schedule" != " " ]]; then
				echo -e "Autoupdate schedule: ${yellow}$update_schedule${no_color}\n"
			else
				echo -e "${red}Error:${no_color} Could not determine autoupdate schedule. Complete cron line:"; echo -e "${autoupdate_job}\n"
			fi
		else
			echo -e "${yellow}NOTE${no_color}: Autoupdate cron job is ${red}missing${no_color}. Automatic ip list updates are ${red}disabled${no_color}.\n"
		fi
	fi
}

restore_from_config() {
# restore tlds from the config file

	echo
	echo -e "Warning: Config incoherence detected between the firewall current status and the config file."
	[[ -n "$unexpected_tlds" ]] && echo "Unexpected tlds in the firewall: '$unexpected_tlds'" >&2
	[[ -n "$missing_tlds" ]] && echo "Missing tlds in the firewall: '$missing_tlds'" >&2
	echo "Would you like to re-apply the rules from the config file to fix this?"
	echo -e "\n'Y' to re-apply the config rules. 'N' to exit the script. 'S' to show country codes in the config file.\n"

	while true; do
		read -p "(Y/N/S) " -n 1 -r

		if [[ "$REPLY" =~ ^[Yy]$ ]]; then echo; break
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then echo -e "\nExiting."; exit 1
		elif [[ "$REPLY" =~ ^[Ss]$ ]]; then
			echo -e "\n\n\n\n$list_type country codes in the config file: '$config_tlds'\n"
		else echo -e "\nPlease press 'y/n/s'.\n"
		fi
	done

	echo "Restoring $list_type countries set '$config_tlds' from the config file... "
	tlds_to_remove="$(merge_lists "$config_tlds" "$unexpected_tlds" "$tlds_to_change")"
	$run_command remove -o -c "$tlds_to_remove"
	[[ -n "$config_tlds" ]] && $run_command add -o -c "$config_tlds"

	check_tlds_coherency; rv=$?
	if [[ $rv -eq 0 ]]; then
		echo "Successfully re-applied previous $list_type countries set."
	else
		echo "Failed to re-apply previous $list_type countries set." >&2
		[[ -n "$unexpected_tlds" ]] && echo "Unexpected $list_type tlds in the firewall: '$unexpected_tlds'" >&2
		[[ -n "$missing_tlds" ]] && echo "Missing $list_type tlds in the firewall: '$missing_tlds'" >&2
		[[ "$ipsets_incoherent" ]] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
		# call the *backup script to initiate recovery from fault
		${suite_name}-backup restore; rv=$?

		check_tlds_coherency; rv1=$?; rv=$(( rv + rv1 ))
		if [[ $rv -eq 0 ]]; then
			echo "Successfully re-applied previous $list_type countries set."
		else
			echo "Failed to re-apply previous $list_type countries set." >&2
			[[ -n "$unexpected_tlds" ]] && echo "Unexpected $list_type tlds in the firewall: '$unexpected_tlds'" >&2
			[[ -n "$missing_tlds" ]] && echo "Missing $list_type tlds in the firewall: '$missing_tlds'" >&2
			[[ "$ipsets_incoherent" ]] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
			die "$rv" "Something is not working as it should. Consider fixing your firewall or your system. If it's a bug then please report it."
		fi
	fi
}

check_for_lockout() {
# tries to prevent the user from locking themselves out

# if we are currently installing, checks local country code vs $planned_tlds list
# if not, checks it vs $tlds_to_change list

# the reason for this distinction is in case the user decides to ignore the warning and proceed,
# if we continue to check vs $planned_tlds then they will have to see the warning every time and reply to it every time,
# even for actions unrelated to their tld
# on the other hand, if we check vs $tlds_to_change during installation, we may miss the fact that their $tld is not included in the whitelist

# if lockout condition is detected, prints a warning and returns 0
# if all is good, or if local country wasn't determined during installation, prints nothing and returns 0
# returns 1 if encounters errors

	local user_tld=""
	local filtered_tld=""
	user_tld="$(getconfig "UserTld")" || { echo "Error: Couldn't read value for UserTld from the config file." >&2; return 1; }

	# if we couldn't get user's country code durint installation, give up on checking for possible lockout
	# otherwise it would be very annoying for the user
	[[ -z "$user_tld" ]] && return 0

	if [[ "$in_install" ]]; then
		filtered_tld="$(find_lists_intersection "$user_tld" "$planned_tlds")"

		case "$list_type" in
			whitelist)
				if [[ -z "$filtered_tld" ]]; then
					msg1="Your country code '$user_tld' is not included in the planned final whitelist '$planned_tlds'.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;

			blacklist)
				if [[ -n "$filtered_tld" ]]; then
					msg1="Your country code '$user_tld' is included in the planned blacklist '$planned_tlds'.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
			*) return 1 ;;
		esac

	else
		filtered_tld="$(find_lists_intersection "$user_tld" "$tlds_to_change")"

		# if user is not doing anything related to their own country code, skip further checks
		[[ -z "$filtered_tld" ]] && return 0

		case "$action" in
			add)
				if [[ "$list_type" = "blacklist" ]]; then
					msg1="You are trying to add your country code '$user_tld' to the blacklist.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
			remove)
				if [[ "$list_type" = "whitelist" ]]; then
					msg1="You are trying to remove your country code '$user_tld' from the whitelist.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
		esac
	fi
}


#### VARIABLES

# set global variables
export list_type="$list_type"

# set environment variable "nolog" to avoid daughter scripts writing errors
#	to syslog when encountering incorrect arguments from the user
export nolog="true"

# set environment variable "manualmode" to signal to daughter scripts that user interaction is possible
export manualmode="true"

# get install_dir from the config file
install_dir="$(getconfig "Installdir")" || die "Error: Couldn't read value for Installdir from the config file."

# get list_type from the config file
list_type="$(getconfig "ListType")" || die "Error: Couldn't read value for ListType from the config file."

[[ "$list_type" != "whitelist" && "$list_type" != "blacklist" ]] &&  die "Error: Unrecognized list type '$list_type'!"

# convert input country codes (tlds) to upper case
tlds_arg="${tlds_arg^^}"

# remove duplicates etc
tlds_arg="$(sanitize_string "$tlds_arg")"

### Read current set of countries from the the config file into config_tlds
config_tlds="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."

# convert the string to lower case
action="${action,,}"

run_command="${install_dir}/${suite_name}-run"


#### CHECKS

missing_deps="$(check_deps jq iptables-save iptables-restore ipset)" || die "Error: missing dependencies: $missing_deps."


# check that the config file exists
[[ ! -f "$conf_file" ]] && die "Config file '$conf_file' doesn't exist! Run the installation script again."

[[ -z "$list_type" ]] && die "\$list_type variable should not be empty! Something is wrong!"

## Check arguments for sanity

[[ -z "$action" ]] && { usage; die "Specify action!"; }

case "$action" in
	add) ;;
	remove) ;;
	status) ;;
	schedule) ;;
	*) usage; die "Error: unsupported action '$action'." ;;
esac

[[ ("$action" = "add" || "$action" = "remove") && -z "$tlds_arg" ]] && \
	die "Error: action '$action' requires to specify countries with '-c <tlds>'!"

[[ "$action" = "schedule" && ( -n "$tlds_arg" || -n "$force_action" ) ]] && \
	die "Action '$action' only supports changing the cron schedule! Do not use it with any option except '-s' or '-d' !"

[[ "$action" = "status" && ( -n "$tlds_arg" || -n "$force_action" ) ]] && \
	die "Command '$action' only supports checking on current status of geoblocking! Do not use it with any option except '-l' or '-d' !"

[[ "$action" != "schedule" && -n "$cron_schedule" ]] && {
	msg1="Error: the '-s <\"cron_schedule\">' option only works with the \"schedule\" action."
	msg2="To set up cron schedule, use '$me schedule -s <\"cron_schedule\">'"
	usage
	die "$msg1" "$msg2";
}


#### MAIN

# check config coherency vs active ipsets and firewall rules before performing any action
check_tlds_coherency || restore_from_config

if [[ "$action" = "status" ]]; then
	report_status
	unset list_type
	unset debugmode
	unset nolog
	unset manualmode
	exit 0
fi


case "$action" in

	add)
		requested_planned_tlds="$(merge_lists "$config_tlds" "$tlds_arg")"
#		debugprint "requested resulting tlds: '$requested_planned_tlds'"

		if [[ -z "$force_action" ]]; then
			# remove any entries already present in config_tlds from tlds_arg and assign to tlds_to_change
			tlds_to_change="$(find_lists_difference "$config_tlds" "$requested_planned_tlds")"

			# find which tlds were specified for addition but already exist
			wrong_tlds="$(find_lists_intersection "$tlds_arg" "$config_tlds")"

			[[ -n "$wrong_tlds" ]] && echo "NOTE: countries '$wrong_tlds' have already been added to the $list_type." >&2
		else
			tlds_to_change="$tlds_arg"
		fi
		planned_tlds="$(merge_lists "$config_tlds" "$tlds_to_change")"
#		debugprint "action: add, tlds_to_change: '$tlds_to_change'"
	;;

	remove)
#		debugprint "requested tlds to remove: '$tlds_arg'"
		if [[ -z "$force_action" ]]; then
			# find duplicate-free intersection between config_tlds and tlds_arg
			tlds_to_change="$(find_lists_intersection "$config_tlds" "$tlds_arg")"
			# find which tlds were specified for removal but don't exist
			good_tlds="$(find_lists_intersection "$tlds_to_change" "$tlds_arg")"
			wrong_tlds="$(find_lists_difference "$tlds_arg" "$good_tlds")"
			[[ -n "$wrong_tlds" ]] && echo "NOTE: countries '$wrong_tlds' have not been added to the $list_type, so can not remove." >&2

		else
			tlds_to_change="$tlds_arg"
		fi
		# remove any entries found in tlds_to_change from config_tlds and assign to planned_tlds
		planned_tlds="$(subtract_list_a_from_b "$tlds_to_change" "$config_tlds")"
	;;
esac


if [[ "$action" != "add" && "$action" != "remove" ]]; then
	debugprint "Skipping the *run script call because specified action was '$action'."
else

	if [[ -z "$tlds_to_change" && -z "$force_action" ]]; then
		config_tlds="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."
		echo -e "\nCountries in final $list_type: '${yellow}$config_tlds${no_color}'."
		die 254 "Nothing to do, exiting."
	fi

	debugprint "planned tlds after '$action': '$planned_tlds'"

	# if planned_tlds list is empty
	if [[ -z "$planned_tlds" && -z "$force_action" && "$list_type" = "whitelist" ]]; then
		die "Planned final countries whitelist is empty! Disallowing this to prevent accidental lockout of a remote server."
	fi

	# try to prevent possible user lock-out
	lockout_expected_msg="$(check_for_lockout)" ||  die "Error in 'check_for_lockout()' function."

	if [[ -n "$lockout_expected_msg" ]]; then
			echo -e "\n${red}Warning${no_color}: $lockout_expected_msg"
			echo -e "\nProceed?"
			while true; do
				read -p "(Y/N) " -n 1 -r
				if [[ "$REPLY" =~ ^[Yy]$ ]]; then echo -e "\nProceeding..."; break
				elif [[ "$REPLY" =~ ^[Nn]$ ]]; then die "Aborted action '$action' for countries '$tlds_to_change'."
				else echo -e "\nPlease press 'y/n'.\n"
				fi
			done
	fi


	### Call the *run script

	$run_command "$action" -c "$tlds_to_change"; rv=$?

	# positive return code means apply failure or another permanent error, except for 254
	if [[ $rv -gt 0 && $rv -ne 254 ]]; then
		echo "Error performing action '$action' for countries '$tlds_to_change'." >&2

		if [[ -z "$config_tlds" ]]; then
			die "Can not restore previous countries set for the $list_type because it is not found in the config file."
		fi
		restore_from_config
	fi

	new_verified_tlds="$(find_active_tlds)"
	failed_tlds="$(find_lists_difference "$new_verified_tlds" "$planned_tlds")"

	if [[ -n "$failed_tlds" ]]; then
		debugprint "planned_tlds: '$planned_tlds', new_verified_tlds: '$new_verified_tlds', failed_tlds: '$failed_tlds'."
		echo "Warning: failed to apply new $list_type rules for countries: $failed_tlds." >&2
		# if the error encountered during installation, exit with error in order to fail the installation
		[[ "$in_install" ]] && die
	fi

	# if all 'add' actions failed
	if [[ -z "$(find_lists_difference "$tlds_to_change" "$failed_tlds")" ]]; then
		die "All actions failed."
	fi

	debugprint "Writing new config to file: 'Countries=$new_verified_tlds'"
	setconfig "Countries=$new_verified_tlds" || die "Failed to write updated tlds '$new_verified_tlds' to the config file"

	config_tlds="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."
#	debugprint "current $list_type countries in config file: '$config_tlds'"

####### Fault recovery test: inject unrequested tld
#[ "$testmode" ] &&	$run_command add -o -c "ge"; rv=$?
#######


	# double-check coherency after applying new tlds
	check_tlds_coherency || { tlds_to_change=""; restore_from_config; }

	echo -e "\nCountries in final $list_type: '${yellow}$config_tlds${no_color}'."
	echo
	[[ ! "$in_install" ]] && echo -e "View current geoblocking status with '${yellow}sudo ${suite_name} status${no_color}'\n"
fi


### Cron jobs management
if [[ "$action" != "schedule" ]]; then
	debugprint "Skipping cron setup because action is not 'schedule'."
else
	[[ -z "$cron_schedule" ]] && cron_schedule="disable"

	# write to the config file in order to communicate parameters to *cronsetup
	setconfig "CronSchedule=$cron_schedule" || die "Failed to write the updated CronSchedule value to the config file"

	${suite_name}-cronsetup; rv=$?
	if [[ "$rv" -eq 0 ]]; then
		echo -e "\nView current cron jobs with 'sudo crontab -l'"
	else
		die "Error: Failed to create or update cron jobs."
	fi
fi

[[ ! "$in_install" ]] && echo

debugexitmsg

unset list_type
unset debugmode
unset nolog
unset manualmode
unset testmode

exit 0
