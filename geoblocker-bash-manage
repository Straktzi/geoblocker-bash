#!/usr/bin/env bash

# geoblocker-bash-manage

# Provides an interface to configure geoblocking.

#### Initial setup

me=$(basename "$0")

# check for root
[ "$EUID" -ne 0 ] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { echo "Error: Couldn't cd into '$script_dir'." >&2; exit 1; }

source "$script_dir/${suite_name}-common" || { echo "Error: Can't find ${suite_name}-common." >&2; exit 1; }
# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"

#### USAGE

usage() {
    cat <<EOF

$me
    Provides an interface to configure geoblocking.

Usage: $me <action> [-c "[tld] [tld] ... [tld]"] [-s <"sch_expression"|disable>] [-f] [-t] [-d] [-h]

Actions:
    add|remove                   : add or remove TLDs (country codes) to/from geoblocking rules
    schedule                     : change the cron schedule (has no effect on iptables rules)
    status                       : check on the current status of geoblocking

Options:
    -c "tld(s)"                   : tld / country codes. if passing multiple country codes, use double quotes.
    -s <"sch_expression"|disable> : schedule expression for the periodic cron job implementing auto-updates of the ip lists,
                                            must be inside double quotes.
                                            default schedule is "0 4 * * *" (at 4:00 [am] every day)
                                        disable: *skip* creating the cron job which is required for automatic updates of the ip list

    -f                            : Force the action even if it doesn't make sense or may cause remote server lockout.
    -t                            : Test mode: inject unexpected tld and verify fault recovery
    -d                            : Debug
    -h                            : This help

EOF
}


#### PARSE ARGUMENTS

# 1st argument should be the requested action
action="$1"
shift 1

while getopts ":c:s:ftdh" opt; do
	case $opt in
		c) tlds_arg=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		f) force_action="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; echo "Error: Unknown option: '-$OPTARG'." >&2; exit 1;;
	esac
done
shift $((OPTIND -1))

# check if there are unprocessed arguments
[[ "$*" != "" ]] && {
	usage
	echo "Error in arguments. First unrecognized argument: '$1'." >&2
	echo -e "Note: If specifying multiple country codes, put them in double braces.\n" >&2
	exit 1
}

echo

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

report_status() {
	echo
	echo "Geoblocking status report:"
	echo
	echo "Geoblocking mode: $list_type."
	echo

	current_input_policy=$(iptables -nL | grep "Chain INPUT" | awk -F'policy |)' '{print $2}')
	current_forward_policy=$(iptables -nL | grep "Chain FORWARD" | awk -F'policy |)' '{print $2}')

	if [ -z "$current_input_policy" ] || [ -z "$current_forward_policy" ]; then
		echo "Error: failed to determine current policies." >&2
	else
		echo -e "Active default iptables policies: \nINPUT: $current_input_policy, FORWARD: $current_forward_policy"
	fi

	# check INPUT chain default policy compatibility with list_type
	echo
	case "$list_type" in
		whitelist) [[ "$current_input_policy" != "DROP" ]] && {
			echo "WARNING: whitelist functionality requires INPUT chain policy to be 'DROP' but it is '$current_input_policy'."
			echo "Essentially, connections from all countries are allowed and whitelist is not working.";
			} || echo "Current INPUT chain policy is compatible with whitelist." ;;
		blacklist) [[ "$current_input_policy" != "ACCEPT" ]] && {
			echo "WARNING: blacklist functionality requires INPUT chain policy to be 'ACCEPT' but it is '$current_input_policy'."
			echo "Essentially, connections from all countries are being blocked which is probably not what you want.";
			} || echo "Current INPUT chain policy is compatible with blacklist." ;;
	esac

	if [ "$list_type" = "whitelist" ]; then
		echo
		echo "Global iptables rules for $suite_name:"
		global_rules="$(iptables-save | grep "${suite_name}_global")"
		[ "$global_rules" = "" ] && echo "None." || echo "$global_rules"
	fi

	echo
	echo "$list_type iptables rules for $suite_name:"
	geoblocking_rules="$(iptables -L -v | grep "match-set ${suite_name}")"
	[ "$geoblocking_rules" = "" ] && echo "None." || echo "$geoblocking_rules"
	echo

	check_tlds_coherency; rv=$?
	if [ "$rv" -ne 0 ]; then
		echo "Warning: discrepancy detected between the config file and iptables rules!" >&2
		[ "$ipsets_incoherent" = "true" ] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
	else
		echo "Coherency check: Countries in the firewall config are coherent with the config file."
	fi

	# check if cron service is enabled
	echo
	(systemctl is-enabled cron.service) > /dev/null || crondisabled="true"
	if [ -n "$crondisabled" ]; then
		echo "WARNING: cron service appears to be disabled. If that's the case, both persistence across reboots and autoupdates will not work."
	else
		echo "Cron system service is enabled, so persistence and ip lists autoupdates are possible."

		# check cron jobs
		echo
		persistence_job="$(crontab -u root -l 2>/dev/null | grep "${suite_name}-persistence")"
		[ "$persistence_job" != "" ] && echo "Persistence cron job is active." || \
			echo "WARNING: Persistence cron job is *not set up*. Geoblocking will not work after reboot."

		echo
		autoupdate_job="$(crontab -u root -l 2>/dev/null | grep "${suite_name}-autoupdate")"
		if [ "$autoupdate_job" != "" ]; then
			echo "Autoupdate cron job is active."
			update_schedule="$(echo "$autoupdate_job" | cut -f1 -d\")"
			if [[ "$update_schedule" != "" && "$update_schedule" != " " ]]; then
				echo "Autoupdate schedule: $update_schedule"
			else
				echo "Could not determine autoupdate schedule. Complete cron line:"; echo "${autoupdate_job}"
			fi
		else
			echo "NOTE: Autoupdate cron job is *not set up*. Automatic ip list updates are disabled."
		fi
	fi

	# check ipsets and iptables rules for active tlds
	echo
	active_tlds="$(find_active_tlds)"; rv=$?
	echo "$list_type is configured for country codes: '$active_tlds'."
	echo
}

restore_from_config() {
# restore tlds from the config file

	echo
	echo -e "Warning: Config incoherence detected between the firewall current status and the config file."
	[ "$unexpected_tlds" != "" ] && echo "Unexpected tlds in the firewall: '$unexpected_tlds'" >&2
	[ "$missing_tlds" != "" ] && echo "Missing tlds in the firewall: '$missing_tlds'" >&2
	echo "Would you like to re-apply the rules from the config file to fix this?"
	echo -e "\n'Y' to re-apply the config rules. 'N' to exit the script. 'S' to show country codes in the config file.\n"

	while [[ "true" ]]; do
		read -p "(Y/N/S) " -n 1 -r

		if [[ "$REPLY" =~ ^[Yy]$ ]]; then echo; break
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then echo -e "\nExiting."; exit 1
		elif [[ "$REPLY" =~ ^[Ss]$ ]]; then
			echo -e "\n\n\n\n$list_type country codes in the config file: '$config_tlds'\n"
		else echo -e "\nPlease press 'y/n/s'.\n"
		fi
	done

	echo "Restoring $list_type countries set '$config_tlds' from the config file... "
	tlds_to_remove="$(merge_lists $config_tlds $unexpected_tlds $tlds_to_change)"
	$run_command remove -o -c "$tlds_to_remove"
	[[ "$config_tlds" != "" ]] && $run_command add -o -c "$config_tlds"

	check_tlds_coherency; rv=$?
	if [ $rv -eq 0 ]; then
		echo "Successfully re-applied previous $list_type countries set."
	else
		echo "Failed to re-apply previous $list_type countries set." >&2
		[ "$unexpected_tlds" != "" ] && echo "Unexpected $list_type tlds in the firewall: '$unexpected_tlds'" >&2
		[ "$missing_tlds" != "" ] && echo "Missing $list_type tlds in the firewall: '$missing_tlds'" >&2
		[ "$ipsets_incoherent" = "true" ] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
		# call the *backup script to initiate recovery from fault
		${suite_name}-backup restore; rv=$?

		check_tlds_coherency; rv1=$?; rv=$(( rv + rv1 ))
		if [ $rv -eq 0 ]; then
			echo "Successfully re-applied previous $list_type countries set."
		else
			echo "Failed to re-apply previous $list_type countries set." >&2
			[ "$unexpected_tlds" != "" ] && echo "Unexpected $list_type tlds in the firewall: '$unexpected_tlds'" >&2
			[ "$missing_tlds" != "" ] && echo "Missing $list_type tlds in the firewall: '$missing_tlds'" >&2
			[ "$ipsets_incoherent" = "true" ] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
			die "$rv" -nolog "Something is not working as it should. Consider fixing your firewall or your system. If it's a bug then please report it."
		fi
	fi
}


#### VARIABLES

# get install_dir from the config file
install_dir="$(getconfig "Installdir")" || { die -nolog "Error: Couldn't read value for Installdir from the config file."; }

# get list_type from the config file
list_type="$(getconfig "ListType")" || { die -nolog "Error: Couldn't read value for ListType from the config file."; }

# set global variables
export list_type="$list_type"
export manualmode="true"

# set environment variable "nolog" to avoid daughter scripts writing errors
#	to syslog when encountering incorrect arguments from the user
#	nolog variable is checked in the sourced *common script
export nolog="true"

# convert input country codes (tlds) to lower case
tlds_arg="${tlds_arg,,}"

# remove duplicates etc
tlds_arg="$(sanitize_string "$tlds_arg")"

### Read current set of countries from the the config file into config_tlds
config_tlds="$(getconfig "Countries")" || { die -nolog "Error: Couldn't read value for Countries from the config file."; }

# convert the string to lower case
action="${action,,}"

run_command="${install_dir}/${suite_name}-run"


#### CHECKS

# check that the config file exists
[ ! -f "$conf_file" ] && die -nolog "Config file '$conf_file' doesn't exist! Run the installation script again."

[ -z "$list_type" ] && die -nolog "\$list_type variable should not be empty! Something is wrong!"

## Check arguments for sanity

[ -z "$action" ] && { usage; die -nolog "Specify action!"; }

case "$action" in
	add) ;;
	remove) ;;
	status) ;;
	schedule) ;;
	*) usage; die -nolog "Error: unsupported action '$action'." ;;
esac

[[ ("$action" == "add" || "$action" == "remove") && -z "$tlds_arg" ]] && \
	die -nolog "Error: action '$action' requires to specify countries with '-c <tlds>'!"

[[ "$action" == "schedule" && ( -n "$tlds_arg" || -n "$force_action" ) ]] && \
	die -nolog "Action '$action' only supports changing the cron schedule! Do not use it with any option except '-s' or '-d' !"

[[ "$action" == "status" && ( -n "$tlds_arg" || -n "$force_action" ) ]] && \
	die -nolog "Command '$action' only supports checking on current status of geoblocking! Do not use it with any option except '-l' or '-d' !"

[ "$action" != "schedule" ] && [ -n "$cron_schedule" ] && {
	msg1="Error: the '-s <\"cron_schedule\">' option only works with the \"schedule\" action."
	msg2="To set up cron schedule, use '$me schedule -s <\"cron_schedule\">'"
	usage
	die -nolog "$msg1" "$msg2";
}


#### MAIN

# check config coherency vs active ipsets and firewall rules before performing any action
check_tlds_coherency || restore_from_config

if [ "$action" = "status" ]; then
	report_status
	unset list_type
	unset debugmode
	unset nolog
	exit 0
fi


case "$action" in

	add)
		requested_planned_tlds="$(merge_lists "$config_tlds" "$tlds_arg")"
#		debugprint "requested resulting tlds: '$requested_planned_tlds'"

		if [ -z "$force_action" ]; then
			# remove any entries already present in config_tlds from tlds_arg and assign to tlds_to_change
			tlds_to_change="$(find_lists_difference "$config_tlds" "$requested_planned_tlds")"

			# find which tlds were specified for addition but already exist
			wrong_tlds="$(find_lists_intersection "$tlds_arg" "$config_tlds")"

			[ "$wrong_tlds" != "" ] && echo "NOTE: countries '$wrong_tlds' have already been added to the $list_type." >&2
		else
			tlds_to_change="$tlds_arg"
		fi
		planned_tlds="$(merge_lists "$config_tlds" "$tlds_to_change")"
#		debugprint "action: add, tlds_to_change: '$tlds_to_change'"
	;;

	remove)
#		debugprint "requested tlds to remove: '$tlds_arg'"
		if [ -z "$force_action" ]; then
			# find duplicate-free intersection between config_tlds and tlds_arg
			tlds_to_change="$(find_lists_intersection "$config_tlds" "$tlds_arg")"
			# find which tlds were specified for removal but don't exist
			good_tlds="$(find_lists_intersection "$tlds_to_change" "$tlds_arg")"
			wrong_tlds="$(find_lists_difference "$tlds_arg" "$good_tlds")"
			[ "$wrong_tlds" != "" ] && echo "NOTE: countries '$wrong_tlds' have not been added to the $list_type, so can not remove." >&2

		else
			tlds_to_change="$tlds_arg"
		fi
		# remove any entries found in tlds_to_change from config_tlds and assign to planned_tlds
		planned_tlds="$(subtract_list_a_from_b "$tlds_to_change" "$config_tlds")"
	;;
esac


if [ "$action" != "add" ] && [ "$action" != "remove" ]; then
	debugprint "Skipping the *run script call because specified action was '$action'."
else

	if [ -z "$tlds_to_change" ] && [ -z "$force_action" ]; then
		config_tlds="$(getconfig "Countries")" || { die -nolog "Error: Couldn't read value for Countries from the config file."; }
		echo; echo "Countries in final $list_type config: '$config_tlds'."
		die 254 -nolog "Nothing to do, exiting."
	fi

	debugprint "planned tlds after '$action': '$planned_tlds'"

	# if planned_tlds list is empty
	if [[ -z "$planned_tlds" && -z "$force_action" && "$list_type" = "whitelist" ]]; then
		die -nolog "Planned final countries whitelist is empty! Disallowing this to prevent accidental lockout of a remote server."
	fi


	### Call the *run script

	$run_command "$action" -o -c "$tlds_to_change"; rv=$?

	# positive return code means apply failure or another permanent error, except for 254
	if [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
		echo "Error performing action '$action' for countries '$tlds_to_change'." >&2

		if [ "$config_tlds" = "" ]; then
			die -nolog "Can not restore previous countries set for $list_type because it is not found in the config file."
		fi
		restore_from_config
	fi

	new_verified_tlds="$(find_active_tlds)"
	failed_tlds="$(find_lists_difference "$new_verified_tlds" "$planned_tlds")"

	if [ "$failed_tlds" != "" ]; then
		echo "Warning: failed to apply new $list_type rules for countries: $failed_tlds." >&2
		# if the error encountered during installation, exit with error in order to fail the installation
		[ "$parent_short" = "install" ] && die
	fi

	# if all 'add' actions failed
	if [ -z "$(find_lists_difference "$tlds_to_change" "$failed_tlds")" ]; then
		die -nolog "All actions failed."
	fi

	debugprint "Writing new config to file: 'Countries=$new_verified_tlds'"
	setconfig "Countries=$new_verified_tlds" || \
		{ die -nolog "Failed to write updated tlds '$new_verified_tlds' to the config file"; }

	config_tlds="$(getconfig "Countries")" || { die -nolog "Error: Couldn't read value for Countries from the config file."; }
#	debugprint "current $list_type countries in config file: '$config_tlds'"

####### Fault recovery test: inject unrequested tld
[ "$test" ] &&	$run_command add -o -c "ge"; rv=$?
#######


	# double-check coherency after applying new tlds
	check_tlds_coherency || { tlds_to_change=""; restore_from_config; }

	## call the backup script
	debugprint "Calling the backup script"
	${suite_name}-backup create-backup
	echo
	echo "Countries in final $list_type: '$config_tlds'."
	echo
	echo "View current geoblocking status with 'sudo ${suite_name} status'"
	echo
fi


### Cron jobs management

if [ "$action" != "schedule" ]; then
	debugprint "Skipping cron setup because action is not 'schedule'."
else

	[[ "$cron_schedule" == "" ]] && cron_schedule="disable"

	# write to the config file in order to communicate parameters to *cronsetup
	setconfig "CronSchedule=$cron_schedule" || { die -nolog "Failed to write the updated CronSchedule value to the config file"; }

	${suite_name}-cronsetup; rv=$?
	echo
	if [ "$rv" -eq 0 ]; then
		echo "View current cron jobs with 'sudo crontab -l'"
	else
		die -nolog "Error: Failed to create cron jobs!"
	fi
fi

echo

debugexitmsg

unset list_type
unset debugmode
unset nolog

exit 0
