#!/usr/bin/env bash

# geoblocker-bash-manage

# Provides an interface to configure geoblocking.

#### Initial setup

me=$(basename "$0")

# check for root
[[ "$EUID" -ne 0 ]] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[[ -n "$script_dir" ]] && cd "$script_dir" || { echo "$me: Error: Couldn't cd into '$script_dir'." >&2; exit 1; }

source "$script_dir/${suite_name}-common" || { echo "$me: Error: Can't source ${suite_name}-common." >&2; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script


# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"

#### USAGE

usage() {
    cat <<EOF

$me
    Provides an interface to configure geoblocking.

Usage: $me <action> [-c "country_code [country_code] ... [country_code]"] [-s <"sch_expression"|disable>] [-f] [-t] [-d] [-h]

Actions:
    add|remove                    : add or remove country codes (ISO 3166-1 alpha-2) to/from geoblocking rules
    schedule                      : change the cron schedule (has no effect on iptables rules)
    status                        : check on the current status of geoblocking

Options:
    -c <"country_codes">          : country codes (ISO 3166-1 alpha-2). if passing multiple country codes, use double quotes.
    -s <"sch_expression"|disable> : schedule expression for the periodic cron job implementing auto-updates of the ip lists,
                                            must be inside double quotes.
                                            default schedule is "0 4 * * *" (at 4:00 [am] every day)
                                        disable: *skip* creating the cron job which is required for automatic updates of the ip list

    -f                            : Force the action even if it doesn't make sense or may cause remote server lockout.
    -t                            : Test mode: inject unexpected ccode and verify fault recovery
    -d                            : Debug
    -h                            : This help

EOF
}


#### PARSE ARGUMENTS

# 1st argument should be the requested action
action="$1"
shift 1

# check for valid action
case "$action" in
	add | remove | schedule | status ) ;;
	* ) usage; err1="Error: Unrecognized action: '$action'."; err2="Specify action in the 1st argument!"; die -nolog "$err1" "$err2" ;;
esac

# process the rest of the arguments
while getopts ":c:s:ftdh" opt; do
	case $opt in
		c) ccodes_arg=$OPTARG;;
		s) cron_schedule=$OPTARG;;
		f) force_action="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		t) testmode=true;;
		\?) usage; echo "Error: Unknown option: '-$OPTARG'." >&2; exit 1;;
	esac
done
shift $((OPTIND -1))

# check if there are unprocessed arguments
[[ -n "$*" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them in double quotation marks."
	die -nolog "$err1" "$err2"
}

echo

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"
export testmode="$testmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

report_status() {
	case "$list_type" in
		whitelist) expected_policy="DROP"; expected_rule_type="ACCEPT"  ;;
		blacklist) expected_policy="ACCEPT"; expected_rule_type="DROP" ;;
		*) die "Error: unrecognized list type '$list_type'!"
	esac

	# read iptables state and ipsets list into env variables to avoid querying iptables and ipset every time
	# check existing variable first and only query if value not set yet
	iptables_output="${iptables_output:-$(iptables -vL)}"
	[[ -z iptables_output ]] && die "Error: failed to get iptables state."
	export iptables_output="$iptables_output"
	export ipset_list="${ipset_list:-$(ipset list -n)}"

	echo -e "\n${yellow}Geoblocking status report:${no_color}"

	echo -e "\nGeoblocking mode: ${yellow}${list_type}${no_color}.\n"

	# report default chain policies
	input_policy="$(awk '$0 ~ "INPUT" {-F"policy| "; print $4}' <<< $iptables_output)"
	forward_policy="$(awk '$0 ~ "FORWARD" {-F"policy| "; print $4}' <<< $iptables_output)"

	if [[ -z "$input_policy" || -z "$forward_policy" ]]; then
		die "Error: failed to determine current policies for INPUT and FORWARD chains."
	fi

	# check ipsets and iptables rules for active ccodes
	active_ccodes="$(find_active_ccodes)"; rv=$?
	if [[ -z "$active_ccodes" ]]; then
		echo -e "${red}Warning${no_color}: no firewall rules found for any country codes!"
	else
		echo -e "$list_type is configured for country codes: '${yellow}$active_ccodes${no_color}'.\n"
	fi

	check_ccodes_coherency; rv=$?
	if [[ "$rv" -ne 0 ]]; then
		echo -e "${red}Error${no_color}: discrepancy detected between the config file and iptables rules!\n" >&2
		[[ "$ipsets_incoherent" ]] && \
			echo -e "${purple}Warning:${no_color} discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!\n" >&2
	else
		echo -e "Country codes in the firewall rules ${green}match${no_color} the config.\n"
	fi

	# report INPUT and FORWARD chain policies
	[[ "$input_policy" = "$expected_policy" ]] && input_policy_colored="${green}${input_policy}${no_color}" || \
		input_policy_colored="${red}${input_policy}${no_color}"
	[[ "$forward_policy" = "$expected_policy" || "$forward_policy" = "DROP" ]] && forward_policy_colored="${green}${forward_policy}${no_color}" || \
		forward_policy_colored="${red}${forward_policy}${no_color}"
	echo -e "Active ${yellow}iptables policies${no_color}: \nINPUT chain: $input_policy_colored, FORWARD chain: $forward_policy_colored\n"

	# check INPUT chain default policy compatibility with list_type
	[[ "$input_policy" != "$expected_policy" ]] && {
				echo -e "${purple}WARNING${no_color}: $list_type functionality requires INPUT chain policy to be '$expected_policy' but it is '$input_policy'."
				echo -e "${red}$list_type is not functioning${no_color}.";
				} || echo -e "INPUT chain policy ${green}is compatible${no_color} with $list_type."

	# check FORWARD chain default policy compatibility with list_type
	[[ "$forward_policy" != "$expected_policy" && "$forward_policy" != "DROP" ]] && {
				echo -e "${purple}WARNING${no_color}: $list_type functionality recommends FORWARD chain policy to be '$expected_policy' but it is '$forward_policy'."
				} || echo -e "FORWARD chain policy ${green}is compatible${no_color} with $list_type."


	# report global iptables rules
	iptables_rules_header="$(grep -m1 "prot opt" <<< "$iptables_output" | cut -b12-150)"

	echo -e "\n${yellow}Global iptables rules${no_color} rules for $suite_name:"
	echo "------------------------------------------------------------------------------------------------------------------------"
	echo -e "$iptables_rules_header"
	echo "------------------------------------------------------------------------------------------------------------------------"
	global_rules="$(grep "${suite_name}_global" <<< "$iptables_output" |cut -b12-170)"
	if [[ -z "$global_rules" ]]; then echo -e "${red}None.${no_color}\n"
	else
		 echo -e "$global_rules\n"
	fi

	# report specific rules for the active geoblocking mode
	echo -e "\n${yellow}$list_type iptables rules${no_color} for $suite_name:"
	echo "------------------------------------------------------------------------------------------------------------------------"
	echo -e "$iptables_rules_header"
	echo "------------------------------------------------------------------------------------------------------------------------"
	geoblocking_rules="$(grep "match-set ${suite_name}" <<< "$iptables_output" | grep "$expected_rule_type" | cut -b12-170)"
	if [[ -z "$geoblocking_rules" ]]; then echo -e "${red}None.${no_color}\n"
	else
		 echo -e "$geoblocking_rules\n"
	fi

	# check if cron service is enabled
	(systemctl is-enabled cron.service) > /dev/null || crondisabled="true"
	if [[ -n "$crondisabled" ]]; then
		echo -e "${purple}WARNING${no_color}: cron service appears to be disabled. Both persistence across reboots and autoupdates will likely not work.\n"
	else
		echo -e "Cron system service is ${green}enabled${no_color}.\n"

		export cron_jobs="${cron_jobs:-"$(crontab -u root -l 2>/dev/null)"}"
		# check cron jobs
		persistence_job="$(grep "${suite_name}-persistence" <<< "$cron_jobs")"
		[[ -n "$persistence_job" ]] && echo -e "${green}Persistence cron job is active${no_color}.\n" || \
			echo -e "${purple}WARNING${no_color}: Persistence cron job is ${red}missing${no_color}. Geoblocking will not work after reboot.\n"

		autoupdate_job="$(grep "${suite_name}-autoupdate" <<< "$cron_jobs")"
		if [[ -n "$autoupdate_job" ]]; then
			echo -e "${green}Autoupdate cron job is active.${no_color}\n"
			update_schedule="$(echo "$autoupdate_job" | cut -f1 -d\")"
			if [[ -n "$update_schedule" && "$update_schedule" != " " ]]; then
				echo -e "Autoupdate schedule: ${yellow}$update_schedule${no_color}\n"
			else
				echo -e "${red}Error:${no_color} Could not determine autoupdate schedule. Complete cron line:"; echo -e "${autoupdate_job}\n"
			fi
		else
			echo -e "${yellow}NOTE${no_color}: Autoupdate cron job is ${red}missing${no_color}. Automatic ip list updates are ${red}disabled${no_color}.\n"
		fi
	fi

	reset_state_vars
}

reset_state_vars(){
# unsets iptables_output, ipset_lists and cron_jobs variables to avoid using irrelevant data
	unset iptables_output
	unset ipset_lists
	unset cron_jobs
}

restore_from_config() {
# restore ccodes from the config file

	echo
	echo -e "Warning: Config incoherence detected between the firewall current status and the config file."
	[[ -n "$unexpected_ccodes" ]] && echo "Unexpected ccodes in the firewall: '$unexpected_ccodes'" >&2
	[[ -n "$missing_ccodes" ]] && echo "Missing ccodes in the firewall: '$missing_ccodes'" >&2
	echo "Would you like to re-apply the rules from the config file to fix this?"
	echo -e "\n'Y' to re-apply the config rules. 'N' to exit the script. 'S' to show country codes in the config file.\n"

	while true; do
		read -p "(Y/N/S) " -n 1 -r

		if [[ "$REPLY" =~ ^[Yy]$ ]]; then echo; break
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then echo -e "\nExiting."; exit 1
		elif [[ "$REPLY" =~ ^[Ss]$ ]]; then
			echo -e "\n\n\n\n$list_type country codes in the config file: '$config_ccodes'\n"
		else echo -e "\nPlease press 'y/n/s'.\n"
		fi
	done

	echo "Restoring $list_type countries set '$config_ccodes' from the config file... "
	ccodes_to_remove="$(merge_lists "$config_ccodes" "$unexpected_ccodes" "$ccodes_to_change")"
	$run_command remove -o -c "$ccodes_to_remove"
	[[ -n "$config_ccodes" ]] && $run_command add -o -c "$config_ccodes"

	reset_state_vars
	check_ccodes_coherency; rv=$?
	if [[ $rv -eq 0 ]]; then
		echo "Successfully re-applied previous $list_type countries set."
	else
		echo "Failed to re-apply previous $list_type countries set." >&2
		[[ -n "$unexpected_ccodes" ]] && echo "Unexpected $list_type ccodes in the firewall: '$unexpected_ccodes'" >&2
		[[ -n "$missing_ccodes" ]] && echo "Missing $list_type ccodes in the firewall: '$missing_ccodes'" >&2
		[[ "$ipsets_incoherent" ]] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
		# call the *backup script to initiate recovery from fault
		${suite_name}-backup restore; rv=$?

		reset_state_vars
		check_ccodes_coherency; rv1=$?; rv=$(( rv + rv1 ))
		if [[ $rv -eq 0 ]]; then
			echo "Successfully re-applied previous $list_type countries set."
		else
			echo "Failed to re-apply previous $list_type countries set." >&2
			[[ -n "$unexpected_ccodes" ]] && echo "Unexpected $list_type ccodes in the firewall: '$unexpected_ccodes'" >&2
			[[ -n "$missing_ccodes" ]] && echo "Missing $list_type ccodes in the firewall: '$missing_ccodes'" >&2
			[[ "$ipsets_incoherent" ]] && echo "Warning: discrepancy detected between existing geoblocking ipsets and geoblocking firewall rules!" >&2
			die "$rv" "Something is not working as it should. Consider fixing your firewall or your system. If it's a bug then please report it."
		fi
	fi
}

check_for_lockout() {
# tries to prevent the user from locking themselves out

# if we are currently installing, checks local country code vs $planned_ccodes list
# if not, checks it vs $ccodes_to_change list

# the reason for this distinction is in case the user decides to ignore the warning and proceed,
# if we continue to check vs $planned_ccodes then they will have to see the warning every time and reply to it every time,
# even for actions unrelated to their ccode
# on the other hand, if we check vs $ccodes_to_change during installation, we may miss the fact that their $ccode is not included in the whitelist

# if lockout condition is detected, prints a warning and returns 0
# if all is good, or if local country wasn't determined during installation, prints nothing and returns 0
# returns 1 if encounters errors

	local user_ccode=""
	local filtered_ccode=""
	user_ccode="$(getconfig "UserCcode")" || { echo "Error: Couldn't read value for UserCcode from the config file." >&2; return 1; }

	# if we couldn't get user's country code durint installation, give up on checking for possible lockout
	# otherwise it would be very annoying for the user
	[[ -z "$user_ccode" ]] && return 0

	if [[ "$in_install" ]]; then
		filtered_ccode="$(find_lists_intersection "$user_ccode" "$planned_ccodes")"

		case "$list_type" in
			whitelist)
				if [[ -z "$filtered_ccode" ]]; then
					msg1="Your country code '$user_ccode' is not included in the planned final whitelist '$planned_ccodes'.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;

			blacklist)
				if [[ -n "$filtered_ccode" ]]; then
					msg1="Your country code '$user_ccode' is included in the planned blacklist '$planned_ccodes'.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
			*) echo -e "\nError: check_for_lockout(): Unexpected list type '$list_type'.\n" >&2; return 1 ;;
		esac

	else
		filtered_ccode="$(find_lists_intersection "$user_ccode" "$ccodes_to_change")"

		# if user is not doing anything related to their own country code, skip further checks
		[[ -z "$filtered_ccode" ]] && return 0

		case "$action" in
			add)
				if [[ "$list_type" = "blacklist" ]]; then
					msg1="You are trying to add your country code '$user_ccode' to the blacklist.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
			remove)
				if [[ "$list_type" = "whitelist" ]]; then
					msg1="You are trying to remove your country code '$user_ccode' from the whitelist.\n"
					msg2="Make sure you do not lock yourself out."
					echo -e "$msg1$msg2"
				fi
				return 0
			;;
			*) echo -e "\nError: check_for_lockout(): Unexpected action '$action'.\n" >&2; return 1 ;;
		esac
	fi
}


#### VARIABLES

# set global variables
export list_type="$list_type"

# set environment variable "nolog" to avoid daughter scripts writing errors
#	to syslog when encountering incorrect arguments from the user
export nolog="true"

# set environment variable "manualmode" to signal to daughter scripts that user interaction is possible
export manualmode="true"

# get install_dir from the config file
install_dir="$(getconfig "Installdir")" || die "Error: Couldn't read value for Installdir from the config file."

# get list_type from the config file
list_type="$(getconfig "ListType")" || die "Error: Couldn't read value for ListType from the config file."

[[ "$list_type" != "whitelist" && "$list_type" != "blacklist" ]] &&  die "Error: Unrecognized list type '$list_type'!"

# convert input country codes (ccodes) to upper case
ccodes_arg="${ccodes_arg^^}"

# remove duplicates etc
ccodes_arg="$(sanitize_string "$ccodes_arg")"

### Read current set of countries from the the config file into config_ccodes
config_ccodes="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."

# convert the string to lower case
action="${action,,}"

run_command="${install_dir}/${suite_name}-run"


#### CHECKS

missing_deps="$(check_deps jq iptables-save iptables-restore ipset)" || die "Error: missing dependencies: $missing_deps."


# check that the config file exists
[[ ! -f "$conf_file" ]] && die "Config file '$conf_file' doesn't exist! Run the installation script again."

[[ -z "$list_type" ]] && die "\$list_type variable should not be empty! Something is wrong!"

## Check arguments for sanity

[[ -z "$action" ]] && { usage; die "Specify action!"; }

case "$action" in
	add) ;;
	remove) ;;
	status) ;;
	schedule) ;;
	*) usage; die "Error: unsupported action '$action'." ;;
esac

# check for valid country codes
if [[ ("$action" = "add" || "$action" = "remove") ]]; then
	[[ -z "$ccodes_arg" ]] &&die "Error: action '$action' requires to specify countries with '-c <country_codes>'!"
		rv=0
	for ccode in $ccodes_arg; do
		validate_ccode "$ccode" || {
			[[ -z "$bad_ccodes" ]] && bad_ccodes="$ccode" || bad_ccodes="$bad_ccodes $ccode"
			(( rv++ ))
		}
	done

	[[ "$rv" -ne 0 ]] && {
		errmsg1="Error: Invalid country codes: '$bad_ccodes'."
		errmsg2="Look up country codes (ISO 3166-1 alpha-2) online and try again."
		die "$errmsg1" "$errmsg2"
	}
fi

[[ "$action" = "schedule" && ( -n "$ccodes_arg" || -n "$force_action" ) ]] && \
	die "Action '$action' only supports changing the cron schedule! Do not use it with any option except '-s' or '-d' !"

[[ "$action" = "status" && ( -n "$ccodes_arg" || -n "$force_action" ) ]] && \
	die "Command '$action' only supports checking on current status of geoblocking! Do not use it with any option except '-l' or '-d' !"

[[ "$action" != "schedule" && -n "$cron_schedule" ]] && {
	msg1="Error: the '-s <\"cron_schedule\">' option only works with the \"schedule\" action."
	msg2="To set up cron schedule, use '$me schedule -s <\"cron_schedule\">'"
	usage
	die "$msg1" "$msg2";
}


#### MAIN

# check config coherency vs active ipsets and firewall rules before performing any action
reset_state_vars
check_ccodes_coherency || restore_from_config

if [[ "$action" = "status" ]]; then
	report_status
	unset list_type
	unset debugmode
	unset nolog
	unset manualmode
	exit 0
fi


case "$action" in

	add)
		requested_planned_ccodes="$(merge_lists "$config_ccodes" "$ccodes_arg")"
#		debugprint "requested resulting ccodes: '$requested_planned_ccodes'"

		if [[ -z "$force_action" ]]; then
			# remove any entries already present in config_ccodes from ccodes_arg and assign to ccodes_to_change
			ccodes_to_change="$(find_lists_difference "$config_ccodes" "$requested_planned_ccodes")"

			# find which ccodes were specified for addition but already exist
			wrong_ccodes="$(find_lists_intersection "$ccodes_arg" "$config_ccodes")"

			[[ -n "$wrong_ccodes" ]] && echo "NOTE: countries '$wrong_ccodes' have already been added to the $list_type." >&2
		else
			ccodes_to_change="$ccodes_arg"
		fi
		planned_ccodes="$(merge_lists "$config_ccodes" "$ccodes_to_change")"
#		debugprint "action: add, ccodes_to_change: '$ccodes_to_change'"
	;;

	remove)
#		debugprint "requested ccodes to remove: '$ccodes_arg'"
		if [[ -z "$force_action" ]]; then
			# find duplicate-free intersection between config_ccodes and ccodes_arg
			ccodes_to_change="$(find_lists_intersection "$config_ccodes" "$ccodes_arg")"
			# find which ccodes were specified for removal but don't exist
			good_ccodes="$(find_lists_intersection "$ccodes_to_change" "$ccodes_arg")"
			wrong_ccodes="$(find_lists_difference "$ccodes_arg" "$good_ccodes")"
			[[ -n "$wrong_ccodes" ]] && echo "NOTE: countries '$wrong_ccodes' have not been added to the $list_type, so can not remove." >&2

		else
			ccodes_to_change="$ccodes_arg"
		fi
		# remove any entries found in ccodes_to_change from config_ccodes and assign to planned_ccodes
		planned_ccodes="$(subtract_list_a_from_b "$ccodes_to_change" "$config_ccodes")"
	;;
esac


if [[ "$action" != "add" && "$action" != "remove" ]]; then
	debugprint "Skipping the *run script call because specified action was '$action'."
else

	if [[ -z "$ccodes_to_change" && -z "$force_action" ]]; then
		config_ccodes="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."
		echo -e "\nCountries in final $list_type: '${yellow}$config_ccodes${no_color}'."
		die 254 "Nothing to do, exiting."
	fi

	debugprint "planned ccodes after '$action': '$planned_ccodes'"

	# if planned_ccodes list is empty
	if [[ -z "$planned_ccodes" && -z "$force_action" && "$list_type" = "whitelist" ]]; then
		die "Planned final countries whitelist is empty! Disallowing this to prevent accidental lockout of a remote server."
	fi

	# try to prevent possible user lock-out
	lockout_expected_msg="$(check_for_lockout)" ||  die "Error in 'check_for_lockout()' function."

	if [[ -n "$lockout_expected_msg" ]]; then
			echo -e "\n${red}Warning${no_color}: $lockout_expected_msg"
			echo -e "\nProceed?"
			while true; do
				read -p "(Y/N) " -n 1 -r
				if [[ "$REPLY" =~ ^[Yy]$ ]]; then echo -e "\n\nProceeding..."; break
				elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
						[[ ! "$in_install" ]] && echo -e "\n\nCountries in final $list_type: '${yellow}$config_ccodes${no_color}'."
						echo
						die "Aborted action '$action' for countries '$ccodes_to_change'."
				else echo -e "\nPlease press 'y/n'.\n"
				fi
			done
	fi


	### Call the *run script

	$run_command "$action" -c "$ccodes_to_change"; rv=$?

	# positive return code means apply failure or another permanent error, except for 254
	if [[ $rv -gt 0 && $rv -ne 254 ]]; then
		echo "Error performing action '$action' for countries '$ccodes_to_change'." >&2

		if [[ -z "$config_ccodes" ]]; then
			die "Can not restore previous countries set for the $list_type because it is not found in the config file."
		fi
		restore_from_config
	fi

	reset_state_vars
	new_verified_ccodes="$(find_active_ccodes)"
	failed_ccodes="$(find_lists_difference "$new_verified_ccodes" "$planned_ccodes")"

	if [[ -n "$failed_ccodes" ]]; then
		debugprint "planned_ccodes: '$planned_ccodes', new_verified_ccodes: '$new_verified_ccodes', failed_ccodes: '$failed_ccodes'."
		echo "Warning: failed to apply new $list_type rules for countries: $failed_ccodes." >&2
		# if the error encountered during installation, exit with error in order to fail the installation
		[[ "$in_install" ]] && die
	fi

	# if all 'add' actions failed
	if [[ -z "$(find_lists_difference "$ccodes_to_change" "$failed_ccodes")" ]]; then
		die "All actions failed."
	fi

	debugprint "Writing new config to file: 'Countries=$new_verified_ccodes'"
	setconfig "Countries=$new_verified_ccodes" || die "Failed to write updated country codes '$new_verified_ccodes' to the config file"

	config_ccodes="$(getconfig "Countries")" || die "Error: Couldn't read value for Countries from the config file."
#	debugprint "current $list_type countries in config file: '$config_ccodes'"

####### Fault recovery test: inject unrequested ccode
#[ "$testmode" ] &&	$run_command add -o -c "ge"; rv=$?
#######


	# double-check coherency after applying new ccodes
	reset_state_vars
	check_ccodes_coherency || { ccodes_to_change=""; restore_from_config; }

	echo -e "\nCountries in final $list_type: '${yellow}$config_ccodes${no_color}'."
	echo
	[[ ! "$in_install" ]] && echo -e "View current geoblocking status with '${yellow}sudo ${suite_name} status${no_color}'\n"
fi


### Cron jobs management
if [[ "$action" != "schedule" ]]; then
	debugprint "Skipping cron setup because action is not 'schedule'."
else
	[[ -z "$cron_schedule" ]] && cron_schedule="disable"

	# write to the config file in order to communicate parameters to *cronsetup
	setconfig "CronSchedule=$cron_schedule" || die "Failed to write the updated CronSchedule value to the config file"

	${suite_name}-cronsetup; rv=$?
	if [[ "$rv" -eq 0 ]]; then
		echo -e "\nView current cron jobs with 'sudo crontab -l'"
	else
		die "Error: Failed to create or update cron jobs."
	fi
fi

[[ ! "$in_install" ]] && echo

debugexitmsg

unset list_type
unset debugmode
unset nolog
unset manualmode
unset testmode

exit 0
