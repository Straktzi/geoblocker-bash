#!/bin/bash -l

# geoblocker_bash-fetch
#
# Based on a prior script by mivk, called get-ripe-ips.
#
# Fetches ipv4 subnets for a given country from RIPE
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates and compiles the downloaded (JSON formatted) list into a plain list, and saves to a file
# Attempts to determine the local ipv4 subnet for the main network interface and appends it to the file

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


me=$(basename "$0")

#### FUNCTIONS

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for a given country from RIPE
2) Then parses, validates and compiles them into plain list, and saves to a file
3) Attempts to determine local subnet for the main network interface and appends it to the file


    Usage: $me -c country -p path [-d] [-h]

    Options:
    -c tld    : tld/country code
    -p path   : Path to directory where downloaded and compiled subnet lists will be stored

    -d        : Debug
    -h        : This help

EOF
}

die() {
	echo "$@" 1>&2
	echo ""
	logger -t geoblocker_bash-fetch "$@"
	exit 1
}

findlocalsubnet() {
# attempts to find local subnet for the main network interface

	# we are relying on the global variable $subnet_regex, so verify that it's not empty
	if [ -z "$subnet_regex" ]; then exit 1; fi

	# returns local ip with subnet mask
	localip="$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}')"

	# Change last ipv4 octet to 0
	localsubnet=$(echo "$localip" | sed 's|\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*|\10|')

	# Verifies that the argument is a valid ipv4 subnet
	echo "$localsubnet" | grep -P "$subnet_regex" &>/dev/null; rv=$?

	if [ $rv -ne 0 ]; then
		# if validation fails, output empty string
		echo ""
	else
		echo "$localsubnet"
	fi
	return $rv
}


#### Parse arguments

while getopts "c:p:dh" opt; do
	case $opt in
	c) country=$OPTARG;;
	p) iplist_path=$OPTARG;;
	d) debug=true;;
	h) usage; exit 0;;
	\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))


#### Initialize variables
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="
url="$ripe_url$country"
min_subnets_num="100"
family="ipv4"    ## only parsing the ipv4 section at this time
filename="${family}_$country"
out_list="$iplist_path/$filename"

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"


#### Checks

if [ -z "$country" ]; then
	usage
	echo ""
	err="Specify country with \"-c <country>\"!"
	die "$err"
fi

# check that we have iplist file path
if [ -z "$iplist_path" ]; then
	usage
	err="Specify iplist file path with \"-p <path-to-file>\"!"
	echo ""
	die "$err"
fi

# use curl or wget, depending on which one we find
if hash curl 2>/dev/null; then
	curl_or_wget="curl -s --retry 4 --fail-early --connect-timeout 7"
elif hash wget 2>/dev/null; then
	curl_or_wget="wget --tries=4 --timeout=7 -qO-"
fi

# check that we have jq
if ! command -v jq &> /dev/null; then
	err="Error: Cannot find \"jq\" - Json processor. Install it with 'apt install jq' or similar. Exiting"
	die "$err"
fi


#### Main

fetched_file=$(mktemp "/tmp/fetched-$country-XXXX.json")

echo -n "Fetching iplist from RIPE... "
[ $debug ] && echo ""
[ $debug ] && echo "Debug: Trying: $curl_or_wget '$url'" >&2

$curl_or_wget "$url" > "$fetched_file"
rv=$?

if [ $rv -ne 0 ]; then
	echo "Failed."
	err="Error $rv trying to run $curl_or_wget $url. Exiting."
	rm "$fetched_file" &>/dev/null
	die "$err"
fi


status=$(jq -r '.status' "$fetched_file")
if [ ! "$status" = "ok" ]; then
	ripe_msg=$(jq -r -c '.messages' "$fetched_file")
	echo "Failed."
	echo "RIPE message: '$ripe_msg'."
	echo "Requested url was: '$url'"
	err="Error: could not fetch ip list from RIPE. Exiting"
	rm "$fetched_file" &>/dev/null
	die "$err"
fi

echo "Success."

## 
if [ -f "$out_list" ]; then
# if $out_list exists then store its date in date_old
	date_old=$(stat --printf "%Y" "$out_list")
else
	date_old=0
fi

# get date of the newly fetched file
ripe_db_time=$(jq -r '.data.query_time' "$fetched_file")
[ $debug ] && echo "Debug: ripe_db_time=$ripe_db_time" >&2
date_new=$(date -d "$ripe_db_time" +%s)

if [ ! "$date_new" -gt "$date_old" ] && [ ! "$debug" ]; then
	echo "Note: Not updating $filename because data querytime did not change: $date_old ($(date --date=@$date_old))."
else
	errorcount=0
	parsed_file=$(mktemp "/tmp/parsed-$country-XXXX.list")
	validated_file=$(mktemp "/tmp/validated-$country-XXXX.list")

	echo -n "Parsing downloaded subnets... "
	jq -r ".data.resources.$family | .[]" "$fetched_file" > "$parsed_file"

	parsed_subnet_cnt=$(wc -l < "$parsed_file")
	if [ "$parsed_subnet_cnt" -ge "$min_subnets_num" ]; then
		echo "Success."
	else
		err="Error: parsed subnets count is less than $min_subnets_num. Probably a download error. Exiting."
		rm "$parsed_file" &>/dev/null
		rm "$validated_file" &>/dev/null
		rm "$fetched_file"
		die "$err"
	fi

	echo -n "Validating downloaded subnets... "
	grep -P "$subnet_regex" "$parsed_file" > "$validated_file"

	validated_subnet_cnt=$(wc -l < "$validated_file")

	errorcount=$((parsed_subnet_cnt - validated_subnet_cnt))

	if [ $errorcount -ne 0 ]; then
		echo "Issues found."
		echo "Warning: $errorcount subnets failed validation." >&2
		echo "Invalid subnets removed from the list." >&2
	else
		if [ "$validated_subnet_cnt" -ge "$min_subnets_num" ]; then
			echo "Success."
		else
			err="Error: validated subnets count is less than $min_subnets_num. Probably a download error. Exiting." >&2
			rm "$parsed_file" &>/dev/null
			rm "$validated_file" &>/dev/null
			rm "$fetched_file"
			die "$err"
		fi
	fi

	echo "Total validated subnets: $validated_subnet_cnt"
	echo ""


	# Add local subnet to the list, only for ipv4
	if [ "$family" = "ipv4" ]; then
		subnet="$(findlocalsubnet)";
		if [ -z "$subnet" ]; then
			err="Error: couldn't determine local subnet."
			rm "$parsed_file" &>/dev/null
			rm "$validated_file" &>/dev/null
			rm "$fetched_file" &>/dev/null
			die "$err"
		else
			echo "Found local subnet: \"$subnet\". Adding it to the list."
			echo "$subnet" >> "$validated_file"
		fi
	fi

	echo -n "Updating $out_list... "
	mv "$validated_file" "$out_list"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Failed."
		err="Error while attempting to overwrite the file $out_list"
		rm "$parsed_file" &>/dev/null
		rm "$validated_file" &>/dev/null
		rm "$fetched_file" &>/dev/null
		die "$err"
	fi
	echo "Ok."
	touch -d "$ripe_db_time" "$out_list"
fi

rm "$parsed_file" &>/dev/null
rm "$validated_file" &>/dev/null
rm "$fetched_file" &>/dev/null
echo ""
