#!/bin/bash -l

# geoblocker_bash-fetch
#
# Based on a prior script by mivk, called get-ripe-ips.
#
# Fetches ipv4 subnets for a given country from RIPE
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates and compiles the downloaded (JSON formatted) list into a plain list, and saves to a file
# Attempts to determine the local ipv4 subnet for the main network interface and appends it to the file

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


me=$(basename "$0")

#### FUNCTIONS

usage() {
    cat <<EOF
This script:
1) Fetches ipv4 subnets for a given country from RIPE
2) Then parses, validates and compiles them into plain list, and saves to a file
3) Attempts to determine local subnet for the main network interface and appends it to the file


    Usage: $me -c country -p path [-d] [-h]

    Options:
    -c tld    : tld/country code
    -p path   : Path to directory where downloaded and compiled subnet lists will be stored

    -d        : Debug
    -h        : This help

EOF
}

die() {
	echo "$@" 1>&2
	echo ""
	logger -t geoblocker_bash-fetch "$@"
	exit 1
}


validate_ipv4_subnet() {
## attempts to make sure that the argument is a valid ipv4 subnet

# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
	regex_pattern='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
	echo "$1" | grep -P $regex_pattern; rv=$?
	# outputs grep result, effectively filtering out invalid subnets

	return $rv
}


findlocalsubnet() {
# attempts to find local subnet for the main network interface

	# returns local ip with subnet mask
	localip="$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}')"

	# Change last ipv4 octet to 0
	localsubnet=$(echo "$localip" | sed 's|\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*|\10|')

	# Sanity check
	(validate_ipv4_subnet "$localsubnet") &>/dev/null; rv=$?

	if [ $rv -ne 0 ]; then
		# if validation fails, output empty string
		echo ""
	else
		echo "$localsubnet"
	fi
	return $rv
}


#### Parse arguments

while getopts "c:p:dh" opt; do
	case $opt in
	c) country=$OPTARG;;
	p) iplist_path=$OPTARG;;
	d) debug=true;;
	h) usage; exit 0;;
	esac
done
shift $((OPTIND -1))


#### Initialize variables
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="
min_size_ipv4=5000  # default is 5000 bytes
min_size_ipv6=2000  # default is 2000 bytes


#### Checks

if [ -z "$country" ]; then
	usage
	echo ""
	err="Error: Specify country with -c! Exiting."
	die "$err"
fi

# check that we have iplist file path
if [ -z "$iplist_path" ]; then
	usage
	err="Error: iplist file path can not be empty. Exiting."
	echo ""
	die "$err"
fi

url="$ripe_url$country"

# use curl or wget, depending on which one we find
curl_or_wget=$(if hash curl 2>/dev/null; then echo "curl -s"; elif hash wget 2>/dev/null; then echo "wget -qO-"; fi);
if [ -z "$curl_or_wget" ]; then
	err="Error: Neither curl nor wget found. Cannot download data. Exiting."
	die "$err"
fi

# check that we have jq
if ! command -v jq &> /dev/null; then
	err="Error: Cannot find the jq Json processor. Install it with 'apt install jq' or similar. Exiting"
	die "$err"
fi


#### Main

tmpfile=$(mktemp "/tmp/ripe-$country-XXXX.json")

[ $debug ] && echo "Debug: Trying: $curl_or_wget '$url'" >&2
echo -n "Fetching iplist from RIPE... "

$curl_or_wget "$url" > "$tmpfile"
rv=$?

if [ $rv -ne 0 ]; then
	echo "Failed."
	err="Error $rv trying to run $curl_or_wget $url. Exiting."
	die "$err"
fi


status=$(jq -r '.status' $tmpfile)
if [ ! "$status" = "ok" ]; then
	ripe_msg=$(jq -r -c '.messages' $tmpfile)
	echo "Failed."
	echo "Error: RIPE replied with status = '$status'."
	echo "The requested url was '$url'"
	echo "and the messages in their reply were: '$ripe_msg'"
	err="Error: could not fetch ip list from RIPE. Exiting"
	die "$err"
fi

echo "Success."

ripe_db_time=$(jq -r '.data.query_time' $tmpfile)
[ $debug ] && echo "Debug: ripe_db_time=$ripe_db_time" >&2
date_new=$(date -d "$ripe_db_time" +%s)

family="ipv4"
## only parsing the ipv4 section at this time

filename="${family}_$country"
out_list="$iplist_path/$filename"

if [ "$family" = "ipv6" ]; then min_size="$min_size_ipv6"; else min_size="$min_size_ipv4"; fi

if [ -f "$out_list" ]; then
	date_old=$(stat --printf "%Y" "$out_list")
else
	date_old=0
fi

if [ ! $date_new -gt $date_old ]; then
	echo "Note: Not updating $filename because data querytime did not change: $date_old ($(date --date=@$date_old))." >&2
else
	[ $debug ]  && echo "Debug: Querytime changed, updating..."
	errorcount=0
	subnetcount=0
	for testsubnet in `jq -r ".data.resources.$family | .[]" "$tmpfile"`; do
		validate_ipv4_subnet "$testsubnet" >> "$out_list.new"; rv=$?
		errorcount=$(($errorcount + $rv))
		subnetcount=$(($subnetcount + 1))
	done

	if [ $errorcount -ne 0 ]; then
		warn="Warning: encountered $errorcount errors while validating subnets in the fetched list."
		echo "warn" >&2
		logger -t geoblocker_bash-fetch "$warn"
		echo "Invalid subnets removed from the list." >&2
	else
		echo "Successfully validated all fetched subnets."
	fi

	echo "Total validated subnets: $(($subnetcount - $errorcount))"
	echo ""
	touch -d "$ripe_db_time" "$out_list.new"

	### Check for minimum size before updating our list

	size=$(stat --printf %s "$out_list.new")

	[ $debug ] && echo "Debug: $filename size: $size"

	if [ "$size" -ge "$min_size" ]; then
		echo -n "Updating $out_list... "
		mv "$out_list.new" "$out_list"; rv=$?
		if [ $rv -ne 0 ]; then
			echo "Failed."
			err="Error while attempting to overwrite the file $out_list"
			rm "$out_list.new"
			rm "$tmpfile"
			die "$err"
		fi
		echo "Ok."

		# Add local subnet to the list, only for ipv4
		if [ "$family" = "ipv4" ]; then
			subnet="$(findlocalsubnet)";
			if [ -z "$subnet" ]; then
				err="Error: couldn't determine local subnet."
				rm "$out_list"
				rm "$tmpfile"
				die "$err"
			else
				echo "Found local subnet: \"$subnet\". Adding it to the list."
				echo "$subnet" >> "$out_list"
			fi
		fi

	else
		echo "Error: fetched file $out_list.new size of $size bytes is smaller than minimum $min_size bytes. Probably a download error. Not updating $filename." >&2
		err="Error: Fetched file $out_list.new is too small: $size bytes. Possibly a download error. Exiting."

		[ $debug ] && echo "Removing previous bad lists for $filename" >&2
		rm "$out_list"*.bad &>/dev/null

		dt=$(date +%F_%H%M%S)
		echo "Saving downloaded list for reference as $out_list-$dt.bad" >&2
		mv "$out_list.new" "$out_list-$dt.bad"
		rm "$tmpfile"
		die "$err"
	fi
fi

rm "$tmpfile"
echo ""
