#!/bin/bash -l

# geoblocker_bash-fetch

# Based on a prior script by mivk, called get-ripe-ips.

# Fetches ipv4 subnets for a given country from RIPE
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates and compiles the downloaded list into a plain list, and saves to a file.

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


me=$(basename "$0")
suite_name="geoblocker_bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { echo "Error: Couldn't cd into '$script_dir'."; exit 1; }

source "${suite_name}-common" || { echo "Error: Can't find ${suite_name}-common."; exit 1; }
# **NOTE** that some functions and variables are sourced from the *common script


#### USAGE

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for a given country from RIPE
2) Then parses, validates and compiles them into plain list, and saves to a file
3) Attempts to determine local subnet for the main network interface and appends it to the file


    Usage: $me -c country -p path [-d] [-h]

    Options:
    -c tld    : tld/country code
    -p path   : Path to directory where downloaded and compiled subnet lists will be stored

    -d        : Debug
    -h        : This help

EOF
}

#### Parse arguments

while getopts "c:p:dh" opt; do
	case $opt in
	c) country=$OPTARG;;
	p) iplist_path=$OPTARG;;
	d) debug=true;;
	h) usage; exit 0;;
	\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo ""

# Print script enter message for debug
debugentermsg

#### FUNCTIONS


#### VARIABLES
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="
url="$ripe_url$country"
min_subnets_num="100"
family="ipv4"    ## only parsing the ipv4 section at this time
filename="${family}_$country"
out_list="$iplist_path/$filename"

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"


#### Checks

if [ -z "$country" ]; then
	usage
	die 1 "Specify country with '-c <country>'!"
fi

# check that we have iplist file path
if [ -z "$iplist_path" ]; then
	usage
	die 1 "Specify iplist file path with '-p <path-to-file>'!"
fi

# use curl or wget, depending on which one we find
if hash curl 2>/dev/null; then
	curl_or_wget="curl -s --retry 4 --fail-early --connect-timeout 7"
elif hash wget 2>/dev/null; then
	curl_or_wget="wget --tries=4 --timeout=7 -qO-"
fi

# check that we have jq
if ! command -v jq &> /dev/null; then
	die 1 "Error: Cannot find 'jq' - Json processor. Install it with 'apt install jq' or similar. Exiting"
fi

# check that iplist directory exists
if [ ! -d "$iplist_path" ]; then
	die 1 "Directory '$iplist_path' doesn't exist!"
fi

#### Main

fetched_file=$(mktemp "/tmp/fetched-$country-XXXX.json")

# debugprint "Trying: $curl_or_wget '$url'" >&2
echo -n "Fetching iplist from RIPE for country '$country'... "

$curl_or_wget "$url" > "$fetched_file"
rv=$?

if [ $rv -ne 0 ]; then
	echo "Failed."
	rm "$fetched_file" &>/dev/null
	die 254 "Failed to run $curl_or_wget $url."
fi


status=$(jq -r '.status' "$fetched_file")
if [ ! "$status" = "ok" ]; then
	ripe_msg=$(jq -r -c '.messages' "$fetched_file")
	echo "Failed."
	echo "RIPE message: '$ripe_msg'."
	echo "Requested url was: '$url'"
	rm "$fetched_file" &>/dev/null
	die 254 "Failed to fetch ip list from RIPE."
fi

echo "Ok."

##
if [ -f "$out_list" ]; then
# if $out_list exists then store its date in date_old
	date_old=$(stat --printf "%Y" "$out_list")
else
	date_old=0
fi

# get date of the newly fetched file
ripe_db_time=$(jq -r '.data.query_time' "$fetched_file")
# debugprint "ripe_db_time=$ripe_db_time" >&2
date_new=$(date -d "$ripe_db_time" +%s)

if [ ! "$date_new" -gt "$date_old" ] && [ ! "$debug" ]; then
	echo "Note: Not updating $filename because data querytime did not change: $date_old ($(date --date=@$date_old))."
else
	errorcount=0
	parsed_file=$(mktemp "/tmp/parsed-$country-XXXX.list")
	validated_file=$(mktemp "/tmp/validated-$country-XXXX.list")

	echo -n "Parsing downloaded subnets... "
	jq -r ".data.resources.$family | .[]" "$fetched_file" > "$parsed_file"

	parsed_subnet_cnt=$(wc -l < "$parsed_file")
	if [ "$parsed_subnet_cnt" -ge "$min_subnets_num" ]; then
		echo "Ok."
	else
		rm "$parsed_file" &>/dev/null
		rm "$validated_file" &>/dev/null
		rm "$fetched_file"
		die 254 "Error: parsed subnets count is less than $min_subnets_num. Probably a download error."
	fi

	echo -n "Validating downloaded subnets... "
	grep -P "$subnet_regex" "$parsed_file" > "$validated_file"

	validated_subnet_cnt=$(wc -l < "$validated_file")

	errorcount=$((parsed_subnet_cnt - validated_subnet_cnt))

	if [ $errorcount -ne 0 ]; then
		echo "Issues found."
		echo "Warning: $errorcount subnets failed validation." >&2
		echo "Invalid subnets removed from the list." >&2
	else
		if [ "$validated_subnet_cnt" -ge "$min_subnets_num" ]; then
			echo "Ok."
		else
			rm "$parsed_file" &>/dev/null
			rm "$validated_file" &>/dev/null
			rm "$fetched_file"
			die 254 "Error: validated subnets count is less than $min_subnets_num. Probably a download error."
		fi
	fi

	echo "Validated $validated_subnet_cnt subnets."
	echo ""

	echo -n "Updating $out_list... "
	mv "$validated_file" "$out_list"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Failed."
		rm "$parsed_file" &>/dev/null
		rm "$validated_file" &>/dev/null
		rm "$fetched_file" &>/dev/null
		die 1 "Failed to overwrite the file $out_list"
	fi
	echo "Ok."
	touch -d "$ripe_db_time" "$out_list"
fi

rm "$parsed_file" &>/dev/null
rm "$validated_file" &>/dev/null
rm "$fetched_file" &>/dev/null
echo ""

debugexitmsg

exit 0
