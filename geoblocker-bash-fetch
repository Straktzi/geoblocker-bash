#!/bin/bash -l

# geoblocker-bash-fetch

# Based on a prior script by mivk, called get-ripe-ips.

# Fetches ipv4 subnets for given country codes from regional internet registry
#     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates the downloaded lists, and saves each one to a separate file.

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


#### Initial setup

me=$(basename "$0")

# check for root
[ "$EUID" -ne 0 ] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	[ ! "$nolog" ] && logger "$err"
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { err="$me: Error: Couldn't cd into '$script_dir'."; echo "$err" >&2; \
	[ ! "$nolog" ] && logger "$err"; exit 1; }

source "$script_dir/${suite_name}-common" || { err="$me: Error: Can't source ${suite_name}-common."; echo "$err" >&2; \
	[ ! "$nolog" ] && logger "$err"; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for given country codes (TLD's) from regional internet registries.
     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)

2) Parses, validates the downloaded lists, and saves each one to a separate file.

Usage: $me -c <"tld [tld] ... [tld]"> -p <path> [-f] [-d] [-h]

Options:
    -c <"country_codes">   : tld's (country codes). if passing multiple country codes, use double quotes
    -p <path>              : Path to directory where downloaded and compiled subnet lists will be stored

    -f                     : force using fetched lists even if list timestamp didn't change compared to existing list
    -d                     : Debug
    -h                     : This help

EOF
}


#### Parse arguments

while getopts ":c:p:fdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		p) iplist_dir=$OPTARG;;

		f) force_update="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		\?) usage; die "Error: Unknown option: '$OPTARG'.";;
	esac
done
shift $((OPTIND -1))

[[ "$*" != "" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them between double quotation marks."
	die "err1" "err2"
}

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

parse_arin() {
	# basically:
	# 1) grep the fetched list to extract this:
	# 	'subnet|ip_addresses_count'
	#	(because this is the data in the ARIN file, don't ask me why they don't just use CIDR instead of ip_addresses_cnt)
	# 2) tr replaces '|' delimiter with ' ' delimiter. now we have 'subnet ip_address_count'
	# 3) awk uses the $cidr_lookup_table to replace ip_addr_count with matching CIDR pattern
	# 	(e.g. '256' gets replaced by '/24')
	#	(awk wants files for its input but we want to avoid creating yet more intermediate files, so we use the <() construct instead)
	# 4) now we have 'subnet /CIDR'
	# 5) tr deletes the ' '
	# 6) finally, we have 'subnet/CIDR' (e.g. 217.10.224.0/24)
	# 7) we write that into $parsed_file which we can use as input to grepcidr
	#
	# slightly crazy? yes. do you have a simpler solution? then please, do let me know.

	awk 'NR==FNR {a[$1] = $2; next} {$2 = a[$2]} 1' <(echo "$cidr_lookup_table") \
		<(grep -oP "(?<=arin\|$tld\|ipv4\|).*?(?=\|[0-9]*?\|allocated)" < "$fetched_file" | tr "|" " ") | \
		tr -d " " > "$parsed_file"

	# check that $parsed_file is non-empty
	[ -s "$parsed_file" ] && rv=0 || rv=1
	return "$rv"
}

parse_ripe() {
	jq -r ".data.resources.$family | .[]" "$fetched_file" > "$parsed_file"; rv=$?
	[[ "$rv" -ne 0 || ! -s "$parsed_file" ]] && rv=1
	return "$rv"
}

get_db_time() {
	case "$registry" in
		RIPE ) db_time=$(jq -r '.data.query_time' "$fetched_file") ;;
		ARIN ) header="$(head -n 1 "$fetched_file")"
				db_time="$(cut -d '|' -f6 <<< "$header")" ;;
	esac
echo "$db_time"
}


#### VARIABLES

arin_url="https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest"
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="

## only parsing the ipv4 section at this time
family="ipv4"

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"

curl_command="curl --retry 8 --fail-early --connect-timeout 5 --progress-bar"
wget_command="wget --tries=8 --timeout=5 --show-progress"

apply_tlds=""
failed_tlds=""

fetch_retries=3

status_file="$iplist_dir/status"


# needed to translate ARIN's quirky data to CIDR
cidr_lookup_table=$(cat <<EOF
1 /32
2 /31
4 /30
8 /29
16 /28
32 /27
64 /26
128 /25
256 /24
512 /23
1024 /22
2048 /21
4096 /20
8192 /19
16384 /18
32768 /17
65536 /16
131072 /15
262144 /14
524288 /13
1048576 /12
2097152 /11
4194304 /10
8388608 /9
16777216 /8
33554432 /7
67108864 /6
EOF
)


#### Checks

[ -z "$tlds" ] && { usage; die 1 "Specify country codes!"; }

# check that we have iplist file path
[ -z "$iplist_dir" ] && { usage; die 1 "Specify iplist directory with '-p <path-to-dir>'!"; }

# check for curl
command -v "curl" &> /dev/null && curl_exists="true"

# check for wget
command -v "wget" &> /dev/null && wget_exists="true"

[[ ! "$curl_exists" && ! "$wget_exists" ]] && die 1 "Error: Neither curl nor wget found."

# check for jq
! command -v jq &> /dev/null && die 1 "Error: Can not find 'jq' - Json processor. Install it with 'apt install jq' or similar."

# check that iplist directory exists
[ ! -d "$iplist_dir" ] && die 1 "Directory '$iplist_dir' doesn't exist!"


#### Main

for tld in $tlds; do

	# capitalize $tld
	tld="${tld^^}"

	case "$tld" in
		AI|AQ|AG|BS|BB|BM|BV|CA|KY|DM|GD|GP|HM|JM|MQ|MS|PR|BL|SH|KN|LC|PM|VC|MF|TC|US|UM|VG|VI )
			registry="ARIN"
			url="$arin_url"
		;;
		* ) registry="RIPE"
			url="${ripe_url}${tld}"
		;;
	esac

	filename="${family}_${tld}"
	list_path="$iplist_dir/${filename}"
	fetched_file=$(mktemp "/tmp/fetched-$tld-XXXX")

	if [ "$wget_exists" ]; then
		fetch_command="$wget_command $url -O"
	elif [ "$curl_exists" ]; then
		fetch_command="$curl_command $url -o"
	fi

	if [ -s "$list_path" ]; then
		old_list_exists="true"
		date_old=$(stat --printf "%Y" "$list_path")
		old_subnets_cnt="$(wc -l < "$list_path")"
		old_failed_subnets_cnt="$(getstatus "$status_file" "LastFailedSubnetsCnt_$tld")" || {
			rm "$fetched_file" &>/dev/null
			die "Error: Couldn't read value for LastFailedSubnetsCnt_$tld from the status file.";
		}
	else
		old_list_exists=""
		date_old=0
	fi

	# reset variables
	retry_cnt=0
	tld_status="unknown"
	validated_subnets_cnt=0
	failed_subnets_cnt=0
	parsed_subnets_cnt=0
	old_failed_subnets_cnt=""

	echo -e "Fetching subnets list for country '$tld'...\n"

	# Make $fetch_retries attempts to fetch the list for each TLD (or until successful fetch and no validation errors)
	while true; do
		retry_cnt=$(( retry_cnt + 1 ))

		$fetch_command "$fetched_file"; rv=$?

		if [[ $rv -ne 0 || ! -s "$fetched_file" ]]; then
			rm "$fetched_file" &>/dev/null
			tld_status="failed"
			echolog "Error when running '$fetch_command'."
			[ "$retry_cnt" -ge "$fetch_retries" ] && break
		else
			echo "Fetch successful."

			# get the date of the fetched file
			db_time="$(get_db_time)";
			date_new=$(date -d "$db_time" +%s)

			# skip list update if data timestamp didn't change, and there were no validation errors in the old list,
			# and we are not in manual mode, and force_update wasn't requested
			if [[ "$old_list_exists" &&  "$date_new" -le "$date_old" && "$force_update" != "true" && \
							"$manualmode" != "true" && "$old_failed_subnets_cnt" -eq 0 ]]; then
				echolog "Subnets list for country '$tld' is already up-to-date. Timestamp: '$(date --date=@$date_new)'."
				tld_status="up_to_date"
				rm "$fetched_file" &>/dev/null
				break
			fi

			# Parse the fetched file
			echo -n "Parsing... "
			parsed_file=$(mktemp "/tmp/parsed-$tld-XXXX.list")

			case "$registry" in
				ARIN ) parse_arin; rv=$? ;;
				RIPE ) parse_ripe; rv=$? ;;
				* ) parse_ripe; rv=$? ;;
			esac
			rm "$fetched_file" &>/dev/null

			if [ "$rv" -ne 0 ]; then
				rm "$parsed_file" &>/dev/null
				tld_status="failed"
				echo -e "\nError: failed to parse the fetched file for country '$tld'." >&2
				[ "$retry_cnt" -ge "$fetch_retries" ] && break
			else
				echo "Ok."
				# Validate the parsed file
				parsed_subnets_cnt=$(wc -l < "$parsed_file")

				echo -n "Validating... "
				validated_file=$(mktemp "/tmp/validated-$tld-XXXX.list")
				grep -P "$subnet_regex" "$parsed_file" > "$validated_file"
				rm "$parsed_file" &>/dev/null

				validated_subnets_cnt=$(wc -l < "$validated_file")

				failed_subnets_cnt=$(( parsed_subnets_cnt - validated_subnets_cnt ))
				if [ "$failed_subnets_cnt" -gt 0 ]; then
					echolog -err "Note: Fetch attempt $retry_cnt for country '$tld': $failed_subnets_cnt subnets failed validation."
					[ "$retry_cnt" -ge "$fetch_retries" ] && { tld_status="partial"; break; }
					rm "$validated_file" &>/dev/null
				else
					echo "Ok."
					tld_status="Ok"
					break
				fi
			fi
		fi
		echo -e "Retrying fetch for country '$tld'...\n"
	done

	if [[ "$tld_status" = "Ok" || "$tld_status" = "partial" ]] && [ "$validated_subnets_cnt" -eq 0 ]; then
		rm "$validated_file" &>/dev/null
		echolog "Error: validated 0 subnets for country '$tld'. Perhaps the country code is incorrect?" >&2
		tld_status="failed"
	fi

	# Check if subnets count decreased dramatically compared to the old list
	# This is to prevent a possible future situation where a regional registry server decides to change API or spew out wrong data
	# and we get something like 0 subnets, all successfully validated and passed as a good list
	if [[ "$old_list_exists" && "$tld_status" != "up_to_date" ]]; then
		# compare fetched subnets count to old subnets count, get result in %
		subnets_percents="$(echo "scale=0 ; $validated_subnets_cnt * 100 / $old_subnets_cnt" | bc)"
		if [ "$subnets_percents" -lt 90 ]; then
			tld_status="failed"
			rm "$validated_file" &>/dev/null
			echolog -err "Warning: validated subnets count '$validated_subnets_cnt' in the fetched list for country '$tld'..."
			echolog -err "is ${subnets_percents}% of '$old_subnets_cnt' subnets in the existing list dated '$(date --date=@$date_old)'."
			echolog -err "Something is wrong! Not updating the list."
		else
			debugprint "Validated subnets count for country '$tld' is ${subnets_percents}% of the count in the existing list"
		fi
	fi

	# If we have a partial list, decide whether to consider it Ok or not
	if [ "$tld_status" = "partial" ]; then
			echolog -err "Warning: out of $parsed_subnets_cnt, $failed_subnets_cnt subnets for country '$tld' failed validation."
			echolog -err "Invalid subnets removed from the list."

		if [ "$old_list_exists" = "true" ]; then
			## don't update the list if it is partial and the count of failed validations increased compared to the old list
			if [ "$failed_subnets_cnt" -gt "$old_failed_subnets_cnt" ]; then
				rm "$validated_file" &>/dev/null
				tld_status="failed"
				err1="Warning: failed subnets count '$failed_subnets_cnt' for country '$tld' is higher than '$old_failed_subnets_cnt' in the old list."
				err2="Not updating the list."
				echolog -err "$err1" "$err2"
			else
				tld_status="Ok"
			fi
		else
			# old list does not exist
			# if we are in manual mode, meaning we were launched from either the *install or the *manage script
			if [ "$manualmode" = "true" ]; then
				# if an older existing list is unavailable, ask the user what to do
				echo -e "\n\nWarning: Ip list for country '$tld' has been fetched but may be incomplete, and there is no older downloaded file for this list."
				echo "Use the incomplete list anyway?"
				while true; do
					read -p "(Y/N) " -n 1 -r
					if [[ "$REPLY" =~ ^[Yy]$ ]]; then tld_status="Ok"; break
					elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
						tld_status="failed"
						rm "$validated_file" &>/dev/null
					else echo -e "\nPlease press 'y/n'.\n"
					fi
				done
			fi
		fi
	fi

	echo

	if [ "$tld_status" = "Ok" ]; then
		echo -e "Validated subnets count for country '$tld': $validated_subnets_cnt.\n"
	fi

	case "$tld_status" in
		Ok | up_to_date ) setstatus "$status_file" "LastFailedSubnetsCnt_${tld}=$failed_subnets_cnt" ;;

		partial | failed ) failed_tlds="$failed_tlds $tld" ;;

		unknown ) echolog -err "Error: validation status for country '$tld' is unknown. This should not happen. Please file a bug report." ;;
		* ) echolog -err "Error: validation status for country '$tld' is '$tld_status' which I don't understand. This should not happen. Please file a bug report." ;;
	esac

	if [ "$tld_status" = "Ok" ]; then

		echo -n "Updating $list_path... "
		mv "$validated_file" "$list_path"; rv=$?
		if [ $rv -ne 0 ]; then
			echo "Failed."
			rm "$validated_file" &>/dev/null
			echolog -err "Failed to overwrite the file '$list_path'"
			failed_tlds="$failed_tlds $tld"
		else
			echo "Ok."
			touch -d "$ripe_db_time" "$list_path"
			apply_tlds="$apply_tlds $tld"
		fi

	fi

	rm "$validated_file" &>/dev/null
done

# report fetch results back to *run via the config file
setstatus "$status_file" "apply_tlds=$apply_tlds" "failed_tlds=$failed_tlds"

debugexitmsg

exit 0
