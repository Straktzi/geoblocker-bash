#!/bin/bash -l

# geoblocker-bash-fetch

# Based on a prior script by mivk, called get-ripe-ips.

# Fetches ipv4 subnets for given country codes from regional internet registry
#     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates the downloaded lists, and saves each one to a separate file.

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


#### Initial setup

me=$(basename "$0")

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { err="$me: Error: Couldn't cd into '$script_dir'."; echo "$err" >&2; \
	[ ! "$nolog" ] && logger "$err"; exit 1; }

source "$script_dir/${suite_name}-common" || { err="$me: Error: Can't source ${suite_name}-common."; echo "$err" >&2; \
	[ ! "$nolog" ] && logger "$err"; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for given country codes (TLD's) from regional internet registries.
     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)

2) Parses, validates the downloaded lists, and saves each one to a separate file.

Usage: $me -c <"tld [tld] ... [tld]"> -p <path> [-o <output_file>] [-s <status_file>] [-f] [-d] [-h]

Options:
    -c <"country_codes">   : tld's (country codes). if passing multiple country codes, use double quotes
    -p <path>              : Path to directory where downloaded and compiled subnet lists will be stored
    -o <output_file>       : Path to output file where fetched list will be stored
                                (use either '-p' or '-o' but not both)
    -s <status_file>       : write fetch results to status file
                                (use when running this script with the suite)

    -f                     : force using fetched lists even if list timestamp didn't change compared to existing list
    -d                     : Debug
    -h                     : This help

EOF
}


#### Parse arguments

while getopts ":c:p:s:o:fdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		p) iplist_dir=$OPTARG;;
		s) status_file=$OPTARG;;
		o) output_file=$OPTARG;;

		f) force_update="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		\?) usage; die "Error: Unknown option: '$OPTARG'.";;
	esac
done
shift $((OPTIND -1))

[[ "$*" != "" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them between double quotation marks."
	die "err1" "err2"
}

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

parse_arin() {

	# what this next quasi-one-liner does (through pipes):
	# 1) grep fetched_file to extract this (in each matching line):
	# 	'subnet|ip_addresses_count'
	#	(because this is the data in the ARIN file, don't ask me why they don't just use CIDR instead of ip_addresses_cnt)
	# 2) tr replaces '|' delimiter with ' ' delimiter. now we have 'subnet ip_address_count'
	# 3) awk uses the $cidr_lookup_table to replace ip_address_count with matching CIDR pattern
	# 	(e.g. '256' gets replaced by '/24')
	#	(awk wants files for its inputs but we want to avoid creating intermediate files, so we use the <() construct instead)
	# 4) now we have 'subnet /CIDR'
	# 5) tr deletes the ' '
	# 6) finally, we have 'subnet/CIDR' (e.g. 217.10.224.0/24)
	# 7) we write that into $parsed_file which we can later validate and feed to the firewall
	#
	# so the pipe chain is: fetched_file->grep->tr->awk(sideloading $cidr_lookup_table)->tr->parsed_file
	# tr commands can be replaced with gsub's in awk but this is not any faster while being more cpu-intensive

	awk 'NR==FNR {a[$1] = $2; next} {$2 = a[$2]} 1' <(printf "%s" "$cidr_lookup_table") \
		<(grep -oP "(?<=arin\|$tld\|ipv4\|).*?(?=\|[0-9]*?\|allocated)" < "$fetched_file" | tr "|" " ") | \
		tr -d " " > "$parsed_file"

	# check that $parsed_file is non-empty
	[ -s "$parsed_file" ] && rv=0 || rv=1
	return "$rv"
}

parse_ripe() {
	jq -r ".data.resources.$family | .[]" "$fetched_file" > "$parsed_file"; rv=$?
	[[ "$rv" -ne 0 || ! -s "$parsed_file" ]] && rv=1
	return "$rv"
}

get_db_time() {
	case "$registry" in
		RIPE ) db_time=$(jq -r '.data.query_time' "$fetched_file") ;;
		ARIN ) header="$(head -n 1 "$fetched_file")"
				db_time="$(cut -d '|' -f6 <<< "$header")" ;;
	esac
echo "$db_time"
}


#### VARIABLES

arin_url="https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest"
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="

## only parsing the ipv4 section at this time
family="ipv4"

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"

curl_command="curl --retry 8 --fail-early --connect-timeout 5 --progress-bar"
wget_command="wget --tries=8 --timeout=5 --show-progress"

tlds_to_update=""
failed_tlds=""
up_to_date_tlds=""
failed_subnets_cnt_str=""

# associative array
declare -A failed_subnets_cnt_arr

fetch_retries=2

# needed to translate ARIN's quirky data to CIDR
# ip scope on the left, matching CIDR pattern on the right
cidr_lookup_table=$(cat <<EOF
1 /32
2 /31
4 /30
8 /29
16 /28
32 /27
64 /26
128 /25
256 /24
512 /23
1024 /22
2048 /21
4096 /20
8192 /19
16384 /18
32768 /17
65536 /16
131072 /15
262144 /14
524288 /13
1048576 /12
2097152 /11
4194304 /10
8388608 /9
16777216 /8
33554432 /7
67108864 /6
EOF
)


#### Checks

missing_deps="$(check_deps jq)" || die "Error: missing dependencies: $missing_deps."

# check for curl
command -v "curl" &> /dev/null && curl_exists="true"

# check for wget
command -v "wget" &> /dev/null && wget_exists="true"

[[ ! "$curl_exists" && ! "$wget_exists" ]] && die "Error: Neither curl nor wget found."

tlds_cnt="$(wc -l <<< "$tlds")"

[ "$tlds_cnt" -eq 0 ] && { usage; die "Specify country code/s!"; }

# check that either $iplist_dir or $output_file is set
[[ -z "$iplist_dir" && -z "$output_file" ]] && { usage; die "Specify iplist directory with '-p <path-to-dir>' or output file with '-o <output_file>'."; }
# ... but not both
[[ -n "$iplist_dir" && -n "$output_file" ]] && { usage; die "Use either '-p <path-to-dir>' or '-o <output_file>' but not both."; }

# if $output_file is set, make sure that no more than 1 tld was specified
[[ -n "$output_file" && "$tlds_cnt" -gt 1 ]] && { usage; die "To fetch lists for multiple country codes, use '-p <path-to-dir>' instead of '-o <output_file>'."; }

# check that iplist directory exists
[[ -n "$iplist_dir" && ! -d "$iplist_dir" ]] && die "Error: Directory '$iplist_dir' doesn't exist!"

[[ -n "$status_file" && ! -f "$status_file" ]] && die "Error: Can not find status file '$status_file'."


#### Main

for tld in $tlds; do

	# capitalize $tld
	tld="${tld^^}"

	case "$tld" in
		AI|AQ|AG|BS|BB|BM|BV|CA|KY|DM|GD|GP|HM|JM|MQ|MS|PR|BL|SH|KN|LC|PM|VC|MF|TC|US|UM|VG|VI )
			registry="ARIN"
			url="$arin_url"
		;;
		* ) registry="RIPE"
			url="${ripe_url}${tld}"
		;;
	esac

	filename="${family}_${tld}"
	# set list_path to $output_file if it is set, or to $iplist_dir/$filename otherwise
	list_path="${output_file:-$iplist_dir/$filename}"
	fetched_file=$(mktemp "/tmp/fetched-$tld-XXXX")

	if [ "$wget_exists" ]; then
		fetch_command="$wget_command $url -O"
	elif [ "$curl_exists" ]; then
		fetch_command="$curl_command $url -o"
	fi

	# reset variables
	retry_cnt=0
	tld_status="unknown"
	validated_subnets_cnt=0
	failed_subnets_cnt=0
	parsed_subnets_cnt=0
	old_failed_subnets_cnt=""

	# if old list exists and $status_file is set, get LastFailedSubnetsCnt_$tld from the status file
	if [[ -s "$list_path" && -n "$status_file" ]]; then
		old_list_exists="true"
		date_old=$(stat --printf "%Y" "$list_path")
		old_subnets_cnt="$(wc -l < "$list_path")"
		old_failed_subnets_cnt="$(getstatus "$status_file" "LastFailedSubnetsCnt_$tld")" || {
			rm "$fetched_file" &>/dev/null
			die "Error: Couldn't read value for LastFailedSubnetsCnt_$tld from the status file.";
		}
	else
		old_list_exists=""
		date_old=0
	fi

	echo -e "Fetching subnets list for country '$tld'...\n"

	# Make $fetch_retries attempts to fetch the list for each TLD (or until successful fetch and no validation errors)
	while true; do
		let retry_cnt++

		$fetch_command "$fetched_file"; rv=$?

		if [[ $rv -ne 0 || ! -s "$fetched_file" ]]; then
			rm "$fetched_file" &>/dev/null
			tld_status="failed"
			echolog "Error when running '$fetch_command'."
			[ "$retry_cnt" -ge "$fetch_retries" ] && break
		else
			echo "Fetch successful."

			# get the date of the fetched file
			db_time="$(get_db_time)";
			date_new=$(date -d "$db_time" +%s)

			# skip list update if data timestamp didn't change, and there were no validation errors in the old list,
			# and we are not in manual mode, and force_update wasn't requested
			if [[ "$old_list_exists" &&  "$date_new" -le "$date_old" && "$force_update" != "true" && \
							"$manualmode" != "true" && "$old_failed_subnets_cnt" -eq 0 ]]; then
				echolog "Subnets list for country '$tld' is already up-to-date. Timestamp: '$(date --date=@$date_new)'."
				tld_status="up_to_date"
				rm "$fetched_file" &>/dev/null
				break
			fi

			# Parse the fetched file
			echo -n "Parsing... "
			parsed_file=$(mktemp "/tmp/parsed-$tld-XXXX.list")

			case "$registry" in
				ARIN ) parse_arin; rv=$? ;;
				RIPE ) parse_ripe; rv=$? ;;
				* ) parse_ripe; rv=$? ;;
			esac
			rm "$fetched_file" &>/dev/null

			if [ "$rv" -ne 0 ]; then
				rm "$parsed_file" &>/dev/null
				tld_status="failed"
				echo -e "\nError: failed to parse the fetched file for country '$tld'." >&2
				[ "$retry_cnt" -ge "$fetch_retries" ] && break
			else
				echo "Ok."
				# Validate the parsed file
				parsed_subnets_cnt=$(wc -l < "$parsed_file")

				echo -n "Validating... "
				validated_file=$(mktemp "/tmp/validated-$tld-XXXX.list")
				grep -P "$subnet_regex" "$parsed_file" > "$validated_file"
				rm "$parsed_file" &>/dev/null

				validated_subnets_cnt=$(wc -l < "$validated_file")

				failed_subnets_cnt=$(( parsed_subnets_cnt - validated_subnets_cnt ))
				if [ "$failed_subnets_cnt" -gt 0 ]; then
					echolog -err "Note: Fetch attempt $retry_cnt for country '$tld': $failed_subnets_cnt subnets failed validation."
					[ "$retry_cnt" -ge "$fetch_retries" ] && { tld_status="partial"; break; }
					rm "$validated_file" &>/dev/null
				else
					echo "Ok."
					tld_status="Ok"
					break
				fi
			fi
		fi
		echo -e "Retrying fetch for country '$tld'...\n"
	done

	if [[ "$tld_status" = "Ok" || "$tld_status" = "partial" ]] && [ "$validated_subnets_cnt" -eq 0 ]; then
		rm "$validated_file" &>/dev/null
		echolog "Error: validated 0 subnets for country '$tld'. Perhaps the country code is incorrect?" >&2
		tld_status="failed"
	fi

	# Check if subnets count decreased dramatically compared to the old list
	# This is to prevent a possible future situation where a regional registry server decides to change API or spew out wrong data
	# and we get something like 0 subnets, all successfully validated and passed as a good list
	if [[ "$old_list_exists" && "$tld_status" != "up_to_date" ]]; then
		# compare fetched subnets count to old subnets count, get result in %
		subnets_percents="$(echo "scale=0 ; $validated_subnets_cnt * 100 / $old_subnets_cnt" | bc)"
		if [ "$subnets_percents" -lt 90 ]; then
			tld_status="failed"
			rm "$validated_file" &>/dev/null
			echolog -err "Warning: validated subnets count '$validated_subnets_cnt' in the fetched list for country '$tld'..."
			echolog -err "is ${subnets_percents}% of '$old_subnets_cnt' subnets in the existing list dated '$(date --date=@$date_old)'."
			echolog -err "Something is wrong! Not updating the list."
		else
			debugprint "Validated subnets count for country '$tld' is ${subnets_percents}% of the count in the existing list"
		fi
	fi

	# If we have a partial list, decide whether to consider it Ok or not
	if [ "$tld_status" = "partial" ]; then
			echolog -err "Warning: out of $parsed_subnets_cnt, $failed_subnets_cnt subnets for country '$tld' failed validation."
			echolog -err "Invalid subnets removed from the list."

		if [ "$old_list_exists" = "true" ]; then
			## don't update the list if it is partial and the count of failed validations increased compared to the old list
			if [ "$failed_subnets_cnt" -gt "$old_failed_subnets_cnt" ]; then
				rm "$validated_file" &>/dev/null
				tld_status="failed"
				err1="Warning: failed subnets count '$failed_subnets_cnt' for country '$tld' is higher than '$old_failed_subnets_cnt' in the old list."
				err2="Not updating the list."
				echolog -err "$err1" "$err2"
			else
				tld_status="Ok"
			fi
		else
			# old list does not exist
			# if we are in manual mode, meaning we were launched from either the *install or the *manage script
			if [ "$manualmode" = "true" ]; then
				# if an older existing list is unavailable, ask the user what to do
				echo -e "\n\nWarning: Ip list for country '$tld' has been fetched but may be incomplete, and there is no older downloaded file for this list."
				echo "Use the incomplete list anyway?"
				while true; do
					read -p "(Y/N) " -n 1 -r
					if [[ "$REPLY" =~ ^[Yy]$ ]]; then tld_status="Ok"; break
					elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
						tld_status="failed"
						rm "$validated_file" &>/dev/null
					else echo -e "\nPlease press 'y/n'.\n"
					fi
				done
			fi
		fi
	fi

	echo

	if [ "$tld_status" = "Ok" ]; then
		echo -e "Validated subnets count for country '$tld': $validated_subnets_cnt.\n"
	fi

	case "$tld_status" in
		Ok | up_to_date ) ;;

		partial | failed ) failed_tlds="$failed_tlds $tld" ;;

		unknown ) echolog -err "Error: validation status for country '$tld' is unknown. This should not happen. Please file a bug report." ;;
		* ) echolog -err "Error: validation status for country '$tld' is '$tld_status' which I don't understand. This should not happen. Please file a bug report." ;;
	esac

	if [ "$tld_status" = "Ok" ]; then

		echo -n "Updating $list_path... "
		mv "$validated_file" "$list_path"; rv=$?
		if [ $rv -ne 0 ]; then
			echo "Failed."
			rm "$validated_file" &>/dev/null
			echolog -err "Failed to overwrite the file '$list_path'"
			failed_tlds="$failed_tlds $tld"
		else
			echo "Ok."
			touch -d "$ripe_db_time" "$list_path"
			tlds_to_update="$tlds_to_update $tld"
			failed_subnets_cnt_arr["$tld"]="$failed_subnets_cnt"
		fi

	fi

	if [ "$tld_status" = "up_to_date" ]; then
		up_to_date_tlds="$up_to_date_tlds $tld"
		failed_subnets_cnt_arr["$tld"]="$failed_subnets_cnt"
	fi

	rm "$validated_file" &>/dev/null
done

# report fetch results back to caller via status file
if [ -n "$status_file" ]; then
	# convert array contents to formatted string for writing to the status file
	for tld in "${!failed_subnets_cnt_arr[@]}"; do

		# new line is intentional
		failed_subnets_cnt_str="$failed_subnets_cnt_str
LastFailedSubnetsCnt_${tld}=${failed_subnets_cnt_arr[$tld]}"
	done

#	debugprint "failed_subnets_cnt_str: '$failed_subnets_cnt_str'"

	setstatus "$status_file" "tlds_to_update=$tlds_to_update" "up_to_date_tlds=$up_to_date_tlds" "failed_tlds=$failed_tlds" "$failed_subnets_cnt_str" || \
		die "Error: Failed to write to the status file '$status_file'."
fi

#debugprint "status file contents:"
#[ "$debugmode" ] && { echo "'" >&2; cat "$status_file"; echo "'" >&2; }

debugexitmsg

exit 0
