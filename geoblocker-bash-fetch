#!/bin/bash -l

# geoblocker-bash-fetch

# Based on a prior script by mivk, called get-ripe-ips.

# Fetches ipv4 subnets for given country codes from RIPE
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates, compiles the downloaded lists, and saves each one to a separate file.

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


#### Initial setup

me=$(basename "$0")

# check for root
[ "$EUID" -ne 0 ] && {
	err="Error: $me needs to be run as root."
	echo "$err" >&2
	logger "$err"
	exit 1
}

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { err="Error: Couldn't cd into '$script_dir'."; echo "$err" >&2; logger "$err" exit 1; }

source "$script_dir/${suite_name}-common" || { err="Error: Can't find ${suite_name}-common."; echo >&2; logger "err"; exit 1; }
# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for given country codes (TLD's) from RIPE.
2) Parses, validates, compiles the downloaded lists, and saves each one to a separate file.

Usage: $me -c <"tld [tld] ... [tld]"> -p <path> [-f] [-d] [-h]

Options:
    -c <"country_codes">   : tld's (country codes). if passing multiple country codes, use double quotes
    -p <path>              : Path to directory where downloaded and compiled subnet lists will be stored

    -f                     : force using fetched lists even if list timestamp didn't change compared to existing list
    -d                     : Debug
    -h                     : This help

EOF
}


#### Parse arguments

while getopts ":c:p:fdh" opt; do
	case $opt in
		c) tlds=$OPTARG;;
		p) iplist_dir=$OPTARG;;

		f) force_update="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		\?) usage; die "Error: Unknown option: '-$OPTARG'.";;
	esac
done
shift $((OPTIND -1))

[[ "$*" != "" ]] && {
	usage
	die "Error in arguments. First unrecognized argument: '$1'."
	exit 1
}

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### VARIABLES
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="
family="ipv4"    ## only parsing the ipv4 section at this time

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"

curl_command="curl --retry 8 --fail-early --connect-timeout 5 --progress-bar"
wget_command="wget --tries=8 --timeout=5 --show-progress"

apply_tlds=""
failed_tlds=""
partial_tlds=""

fetch_retries=3

status_file="$iplist_dir/status"

#### Checks

[ -z "$tlds" ] && { usage; die 1 "Specify country codes!"; }

# check that we have iplist file path
[ -z "$iplist_dir" ] && { usage; die 1 "Specify iplist directory with '-p <path-to-dir>'!"; }

# check for curl
command -v "curl" &> /dev/null && curl_exists="true"

# check for wget
command -v "wget" &> /dev/null && wget_exists="true"

[[ ! "$curl_exists" && ! "$wget_exists" ]] && die 1 "Error: Neither curl nor wget found."

# check for jq
! command -v jq &> /dev/null && die 1 "Error: Can not find 'jq' - Json processor. Install it with 'apt install jq' or similar."

# check that iplist directory exists
[ ! -d "$iplist_dir" ] && die 1 "Directory '$iplist_dir' doesn't exist!"


#### Main

for tld in $tlds; do

	url="$ripe_url$tld"
	filename="${family}_${tld}"
	list_path="$iplist_dir/${filename}"
	fetched_file=$(mktemp "/tmp/fetched-$tld-XXXX.json")

	if [ -s "$list_path" ]; then
		old_list_exists="true"
		date_old=$(stat --printf "%Y" "$list_path")
	else
		old_list_exists=""
		date_old=0
	fi

	# reset variables
	retry_cnt=0
	tld_status="unknown"
	validated_subnets_cnt=0
	failed_subnets_cnt=0
	parsed_subnets_cnt=0
	old_failed_subnet_cnt=""

	# Make $fetch_retries attempts to fetch the list for each TLD (or until successful fetch and no validation errors)
	while true; do
		retry_cnt=$(( retry_cnt + 1 ))

		if [ "$wget_exists" ]; then
			fetch_command="$wget_command $url -O $fetched_file"
		elif [ "$curl_exists" ]; then
			fetch_command="$curl_command $url -o $fetched_file"
		fi

		# debugprint "Trying: $curl_or_wget '$ripe_url$tld'" >&2
		echo -e "Fetching iplist from RIPE for country '$tld'... \n"

		$fetch_command; rv=$?

		if [ $rv -ne 0 ]; then
			rm "$fetched_file" &>/dev/null
			die 254 "Error when running $fetch_command."
		fi

		status=$(jq -r '.status' "$fetched_file")
		if [ ! "$status" = "ok" ]; then
			echolog -err "Failed to fetch the list for country '$tld'."
			ripe_msg=$(jq -r -c '.messages' "$fetched_file")
			debugprint "RIPE replied with message: '$ripe_msg'"
			rm "$fetched_file" &>/dev/null
			tld_status="failed"
		fi

		echo -e "\nFetch successful.\n"

		# get the date of the fetched file
		ripe_db_time=$(jq -r '.data.query_time' "$fetched_file")
		date_new=$(date -d "$ripe_db_time" +%s)

		if [ "$old_list_exists" ]; then
			old_failed_subnets_cnt="$(getstatus "$status_file" "LastFailedSubnetsCnt_$tld")" || {
				rm "$fetched_file" &>/dev/null
				die "Error: Couldn't read value for LastFailedSubnetsCnt_$tld from the config file.";
			}
			if [[ "$date_new" -le "$date_old" && "$force_update" != "true" && "$manualmode" != "true" && "$old_failed_subnets_cnt" -eq 0 ]]; then
				echolog "Subnets list for country '$tld' is up-to-date. Timestamp: '$(date --date=@$date_new)'."
				tld_status="up_to_date"
				rm "$fetched_file" &>/dev/null
				break
			fi
		fi


		parsed_file=$(mktemp "/tmp/parsed-$tld-XXXX.list")

		# Parse the fetched file
		echo -n "Parsing... "
		jq -r ".data.resources.$family | .[]" "$fetched_file" > "$parsed_file"; rv=$?

		rm "$fetched_file" &>/dev/null

		if [ "$rv" -ne 0 ]; then
			rm "$parsed_file" &>/dev/null
			tld_status="failed"
			echolog "Error: failed to parse the fetched file for country '$tld'."
			[ "$retry_cnt" -ge "$fetch_retries" ] && break || echolog "Retrying fetch..." >&2
		else
			echo "Ok."
			# Validate the parsed file
			parsed_subnets_cnt=$(wc -l < "$parsed_file")

			echo -n "Validating... "
			validated_file=$(mktemp "/tmp/validated-$tld-XXXX.list")
			grep -P "$subnet_regex" "$parsed_file" > "$validated_file"
			rm "$parsed_file" &>/dev/null

			validated_subnets_cnt=$(wc -l < "$validated_file")

			failed_subnets_cnt=$(( parsed_subnets_cnt - validated_subnets_cnt ))
			if [ "$failed_subnets_cnt" -gt 0 ]; then
				echo "Note: Fetch attempt $retry_cnt for country '$tld': $failed_subnets_cnt subnets failed validation." >&2
				[ "$retry_cnt" -ge "$fetch_retries" ] && { tld_status="partial"; break; }
				rm "$validated_file" &>/dev/null
				echolog "Retrying fetch..." >&2
			else
				echo "Ok."
				tld_status="Ok"
				break
			fi
		fi
	done

	# Check if subnets count decreased dramatically compared to the old list
	# This is to prevent a possible future situation where RIPE server decides to change API or spew out wrong data
	# and we get something like 0 subnets, all successfully validated and passed as a good list
	if [[ "$old_list_exists" && "$tld_status" = "Ok" ]]; then
		old_subnets_cnt="$(wc -l < "$list_path")"
		# compare fetched subnets count to old subnets count, get result in %
		subnets_percents="$(echo "scale=0 ; $validated_subnets_cnt * 100 / $old_subnets_cnt" | bc)"
		if [ "$subnets_percents" -lt 90 ]; then
			tld_status="failed"
			rm "$validated_file" &>/dev/null
			echolog -err "Warning: validated subnets count '$validated_subnets_cnt' in the fetched list for country '$tld'..."
			echolog -err "is ${subnets_percents}% of '$old_subnets_cnt' subnets in the existing list dated '$(date --date=@$date_old)'."
			echolog -err "Something is wrong! Not updating the list."
		else
			debugprint "Validated subnets count for country '$tld' is ${subnets_percents}% of the count in the existing list"
		fi
	fi
	
	# If we have a partial list, decide whether to consider it Ok or not
	if [ "$tld_status" = "partial" ]; then
			echolog -err "Warning: $failed_subnets_cnt subnets for country '$tld' failed validation."
			echolog -err "Invalid subnets removed from the list."

		if [ "$old_list_exists" = "true" ]; then
			## don't update the list if it is partial and the count of failed validations increased compared to the old list
			if [ "$failed_subnets_cnt" -gt "$old_failed_subnets_cnt" ]; then
				rm "$validated_file" &>/dev/null
				tld_status="failed"
				err1="Warning: failed subnets count '$failed_subnets_cnt' for country '$tld' is higher than '$old_failed_subnets_cnt' in the old list."
				err2="Not updating the list."
				echolog -err "$err1" "$err2"
			else
				tld_status="Ok"
			fi
		else
			# old list does not exist
			# if we are in manual mode, meaning we were launched from either the *install or the *manage script
			if [ "$manualmode" = "true" ]; then
				# if an older existing list is unavailable, ask the user what to do
				echo -e "\n\nWarning: Ip list for country '$tld' has been fetched but may be incomplete, and there is no older downloaded file for this list."
				echo "Use the incomplete list anyway?"
				while true; do
					read -p "(Y/N) " -n 1 -r
					if [[ "$REPLY" =~ ^[Yy]$ ]]; then tld_status="Ok"; break
					elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
						tld_status="failed"
						rm "$validated_file" &>/dev/null
					else echo -e "\nPlease press 'y/n'.\n"
					fi
				done
			fi
		fi
	fi

	if [[ "$tld_status" = "Ok" || "$tld_status" = "partial" ]]; then
		echo -e "Validated subnets count for country '$tld': $validated_subnets_cnt.\n"
	fi

	case "$tld_status" in
		Ok | up_to_date ) setstatus "$status_file" "LastFailedSubnetsCnt_${tld}=$failed_subnets_cnt" ;;

		partial | failed ) failed_tlds="$failed_tlds $tld" ;;

		unknown ) echolog -err "Error: validation status for country '$tld' is unknown. This should not happen. Please file a bug report." ;;
		* ) echolog -err "Error: validation status for country '$tld' is '$tld_status' which I don't understand. This should not happen. Please file a bug report." ;;
	esac

	if [ "$tld_status" = "Ok" ]; then

		echo -n "Updating $list_path... "
		mv "$validated_file" "$list_path"; rv=$?
		if [ $rv -ne 0 ]; then
			echo "Failed."
			rm "$validated_file" &>/dev/null
			echolog -err "Failed to overwrite the file '$list_path'"
			tld_status="failed"
		else
			echo "Ok."
			touch -d "$ripe_db_time" "$list_path"
			apply_tlds="$apply_tlds $tld"
		fi

	fi

	rm "$validated_file" &>/dev/null

done

# report fetch results back to *run via the config file
setstatus "$status_file" "apply_tlds=$apply_tlds" "failed_tlds=$failed_tlds"

debugexitmsg

exit 0
