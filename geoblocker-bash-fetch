#!/bin/bash -l

# geoblocker-bash-fetch

# Based on a prior script by mivk, called get-ripe-ips.

# Fetches ipv4 subnets for given country codes from regional internet registry
#     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)
## See https://stat.ripe.net/docs/data_api
#
# Parses, validates the downloaded lists, and saves each one to a separate file.

# Requires jq - JSON processor.
## On Debian and derivatives, if you are missing jq then install it using this command:
## apt install jq


#### Initial setup

me=$(basename "$0")

suite_name="geoblocker-bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[[ -n "$script_dir" ]] && cd "$script_dir" || { err="$me: Error: Couldn't cd into '$script_dir'."; echo "$err" >&2; \
	[[ ! "$nolog" ]] && logger "$err"; exit 1; }

source "$script_dir/${suite_name}-common" || { err="$me: Error: Can't source ${suite_name}-common."; echo "$err" >&2; \
	[[ ! "$nolog" ]] && logger "$err"; exit 1; }

# **NOTE** that some functions and variables are sourced from the *common script

# sanitize arguments
sanitize_args "$@"
# replace arguments with sanitized ones
set -- "${arguments[@]}"


#### USAGE

usage() {
    cat <<EOF

This script:
1) Fetches ipv4 subnets for given country codes from regional internet registries.
     (currently only RIPE and ARIN implemented but RIPE seems to store lists for all countries)

2) Parses, validates the downloaded lists, and saves each one to a separate file.

Usage: $me -c <"country_code [country_code] ... [country_cod]"> -p <path> [-o <output_file>] [-s <status_file>] [-f] [-d] [-h]

Options:
    -c <"country_codes">   : country codes (ISO 3166-1 alpha-2). if passing multiple country codes, use double quotes
    -p <path>              : Path to directory where downloaded and compiled subnet lists will be stored
    -o <output_file>       : Path to output file where fetched list will be stored.
                                With this option, specify exactly 1 country code.
                                (use either '-p' or '-o' but not both)
    -s <status_file>       : path to a status file to write fetch results to

    -f                     : force using fetched lists even if list timestamp didn't change compared to existing list
    -d                     : Debug
    -h                     : This help

EOF
}


#### Parse arguments

while getopts ":c:p:s:o:fdh" opt; do
	case $opt in
		c) ccodes=$OPTARG;;
		p) iplist_dir=$OPTARG;;
		s) status_file=$OPTARG;;
		o) output_file=$OPTARG;;

		f) force_update="true";;
		d) debugmode_args="true";;
		h) usage; exit 0;;
		\?) usage; die "Error: Unknown option: '$OPTARG'.";;
	esac
done
shift $((OPTIND -1))

[[ -n "$*" ]] && {
	usage
	err1="Error in arguments. First unrecognized argument: '$1'."
	err2="Note: If specifying multiple country codes, put them between double quotation marks."
	die "err1" "err2"
}

# get debugmode variable from either the args or environment variable, depending on what's set
debugmode="${debugmode_args:-$debugmode}"
# set env var to match the result
export debugmode="$debugmode"

# Print script enter message for debug
debugentermsg


#### FUNCTIONS

parse_arin() {

# lookup table needed to translate ARIN's quirky data to CIDR patterns
# ip addresses number on the left, matching CIDR pattern on the right
# delimited by pipe because this is the delimiter in ARIN's data and using the same delimiter makes it easier to process with awk
cidr_lookup_table=$(cat <<EOF
1|/32
2|/31
4|/30
8|/29
16|/28
32|/27
64|/26
128|/25
256|/24
512|/23
1024|/22
2048|/21
4096|/20
8192|/19
16384|/18
32768|/17
65536|/16
131072|/15
262144|/14
524288|/13
1048576|/12
2097152|/11
4194304|/10
8388608|/9
16777216|/8
33554432|/7
67108864|/6
EOF
)

	# older solution, much more complex, slightly slower and less flexible (e.g. more work to adapt it to ipv6 in the future)
	#	awk 'NR==FNR {a[$1] = $2; next} {$2 = a[$2]} 1' <(printf "%s" "$cidr_lookup_table") \
	#		<(grep -oP "(?<=arin\|$ccode\|$family\|).*?(?=\|[0-9]*?\|allocated)" < "$fetched_file" | tr "|" " ") | \
	#	tr -d " " > "$parsed_file"

	# 2nd older solution, works well on x86 cpus but slow on embedded
	# uses 2 "files" for awk input: 1st is the cidr lookup table (fed into awk using the <() construct) 2nd is the fetched file.
	# BEGIN {FS="\\|"} instructs awk to use | as field separator.
	# "a[$1] = $2" compiles the lookup table into an associative array named "a" in awk,
	# using the 1st field (ip count) of the table as key and 2nd field (cidr pattern) as value.
	# next portion filters the lines in the fetched file for "$ccode|$family" and "allocated".
	# "print $4 a[$5]" takes the 4th field (ip subnet) in every resulting line,
	# then uses the 5th field (ip count) as a key to get matching CIDR pattern from the array, and that gets appended to the output line.

	#awk -v family="$family" -v ccode="$ccode" 'BEGIN {FS="\\|"} NR==FNR {a[$1] = $2; next} $0 ~ ccode"\\|"family".*\\|allocated" {print $4 a[$5]}' \
	#<(printf "%s\n" "$cidr_lookup_table") "$fetched_file" > "$parsed_file"

	# newer solution, at least 3x faster on embedded cpu. all processing is done in memory because i/o in embedded may be slow
	# first we use grep -F, which is very fast, to filter only wanted lines
	# we pipe that into cut which removes everything except the 4th and the 5th fields in every line (ip and addresses count)
	# now awk has much less data to process, so it's faster. it works the same way as in the 2nd solution (read above)
	trimmed_arin="$(grep -F "$ccode|$family" "$fetched_file" | grep -F 'allocated' | cut -d\| -f4-5)"
	parsed_list="$(awk 'BEGIN {FS="\\|"} NR==FNR {a[$1] = $2; next} {print $1 a[$2]}' <(printf "%s\n" "$cidr_lookup_table") <(printf "%s\n" "$trimmed_arin"))"

	# check that $parsed_list is non-empty
	[[ -n "$parsed_list" ]] && rv=0 || rv=1
	return "$rv"
}

parse_ripe() {
	parsed_list="$(jq -r ".data.resources.$family | .[]" "$fetched_file")"; rv=$?
	[[ "$rv" -ne 0 || -z "$parsed_list" ]] && rv=1
	return "$rv"
}

get_db_time() {
	case "$registry" in
		RIPE ) ripe_time=$(jq -r '.data.query_time' "$fetched_file")
				# remove T in the middle
				db_time="${ripe_time/T/' '}"
		;;
		ARIN ) header="$(head -n 1 "$fetched_file")"
				arin_time="$(cut -d '|' -f6 <<< "$header")"
				# convert to more compatible date format yyyy-mm-dd
				db_time="${arin_time:0:4}-${arin_time:4:2}-${arin_time:6}"
		;;
	esac
	echo "$db_time"
}


#### VARIABLES

arin_url="https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest"
ripe_url="https://stat.ripe.net/data/country-resource-list/data.json?v4_format=prefix&resource="

## only parsing the ipv4 section at this time
family="ipv4"

# regex patterns used for ipv4 validation
# using Perl regex syntax because grep is faster with it than with native grep syntax
# regex compiled from 2 suggestions found here:
# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
subnet_regex="${ip_regex}${mask_regex}"

curl_command="curl --retry 8 --fail-early --connect-timeout 5 --progress-bar"
wget_command="wget --tries=8 --timeout=5 --show-progress"

ccodes_to_update=""
failed_ccodes=""
up_to_date_ccodes=""
failed_subnets_cnt_str=""

# associative array
declare -A failed_subnets_cnt_arr

fetch_retries=2


#### Checks

missing_deps="$(check_deps jq)" || die "Error: missing dependencies: $missing_deps."

ccodes_cnt="$(wc -l <<< "$ccodes")"

[[ "$ccodes_cnt" -eq 0 ]] && { usage; die "Specify country code/s!"; }

# check that either $iplist_dir or $output_file is set
[[ -z "$iplist_dir" && -z "$output_file" ]] && { usage; die "Specify iplist directory with '-p <path-to-dir>' or output file with '-o <output_file>'."; }
# ... but not both
[[ -n "$iplist_dir" && -n "$output_file" ]] && { usage; die "Use either '-p <path-to-dir>' or '-o <output_file>' but not both."; }

# if $output_file is set, make sure that no more than 1 ccode was specified
[[ -n "$output_file" && "$ccodes_cnt" -gt 1 ]] && { usage; die "To fetch lists for multiple country codes, use '-p <path-to-dir>' instead of '-o <output_file>'."; }

# check that iplist directory exists
[[ -n "$iplist_dir" && ! -d "$iplist_dir" ]] && die "Error: Directory '$iplist_dir' doesn't exist!"

[[ -n "$status_file" && ! -f "$status_file" ]] && { touch "$status_file" || die "Error: failed to create status file '$status_file'."; }
[[ -n "$output_file" && ! -f "$output_file" ]] && { touch "$output_file" || die "Error: failed to create output file '$output_file'."; }



#### Main

for ccode in $ccodes; do

	# capitalize $ccode
	ccode="${ccode^^}"

	case "$ccode" in
		# ARIN country codes
		AI|AQ|AG|BS|BB|BM|BV|CA|KY|DM|GD|GP|HM|JM|MQ|MS|PR|BL|SH|KN|LC|PM|VC|MF|TC|US|UM|VG|VI )
			registry="ARIN"
			url="$arin_url"
		;;
		# non-ARIN country codes
		* ) registry="RIPE"
			url="${ripe_url}${ccode}"
		;;
	esac

	filename="${family}_${ccode}"
	# set list_path to $output_file if it is set, or to $iplist_dir/$filename otherwise
	list_path="${output_file:-$iplist_dir/$filename}"
	fetched_file="/tmp/fetched-$ccode.tmp"

	if [[ "$wget_exists" ]]; then
		fetch_command="$wget_command $url -O"
	elif [[ "$curl_exists" ]]; then
		fetch_command="$curl_command $url -o"
	fi

	# reset variables
	retry_cnt=0
	ccode_status="unknown"
	validated_subnets_cnt=0
	failed_subnets_cnt=0
	parsed_subnets_cnt=0
	old_failed_subnets_cnt=""

	# if $status_file is set and old list physically exists, get LastFailedSubnetsCnt_$ccode from the status file
	if [[ -s "$list_path" && -n "$status_file" ]]; then
		old_list_exists="true"
		old_subnets_cnt="$(wc -l < "$list_path")"
		if [[ "$old_subnets_cnt" -gt 0 ]]; then
			date_old=$(date -r "$list_path" +%s)
			old_failed_subnets_cnt="$(getstatus "$status_file" "LastFailedSubnetsCnt_$ccode")"; rv=$?
			case "$rv" in
				0) ;;
				1) die "*common: Error in getconfig() function." ;;
				2)
					echolog "Note: status file '$status_file' has no information for country '$ccode'."
					rm "$fetched_file" &>/dev/null
					old_list_exists=""
					date_old=0
				;;
			esac
		else
			old_list_exists=""
			date_old=0
		fi
	else
		old_list_exists=""
		date_old=0
	fi

	echo -e "Fetching subnets list for country '$ccode'...\n"

	# Make $fetch_retries attempts to fetch the list for each ccode (or until successful fetch and no validation errors)
	while true; do
		let retry_cnt++

		$fetch_command "$fetched_file"; rv=$?

		if [[ $rv -ne 0 || ! -s "$fetched_file" ]]; then
			rm "$fetched_file" &>/dev/null
			ccode_status="failed"
			echolog "Error when running '$fetch_command'."
			[[ "$retry_cnt" -ge "$fetch_retries" ]] && break
		else
			echo "Fetch successful."

			# get the date of the fetched file
			db_time="$(get_db_time)";
			date_new=$(date -d "$db_time" +%s)

			# skip list update if data timestamp didn't change, and there were no validation errors in the old list,
			# and we are not in manual mode, and force_update wasn't requested
			if [[ "$old_list_exists" &&  "$date_new" -le "$date_old" && ! "$force_update" && \
							! "$manualmode" && "$old_failed_subnets_cnt" -eq 0 ]]; then
				echolog "Subnets list for country '$ccode' is already up-to-date. Timestamp: '$(date --date=@$date_new)'."
				ccode_status="up_to_date"
				rm "$fetched_file" &>/dev/null
				break
			fi

			# Parse the fetched file
			echo -n "Parsing... "
			unset parsed_list

			case "$registry" in
				ARIN ) parse_arin; rv=$? ;;
				RIPE ) parse_ripe; rv=$? ;;
				* ) parse_ripe; rv=$? ;;
			esac
			rm "$fetched_file" &>/dev/null

			if [[ "$rv" -ne 0 ]]; then
				unset parsed_list
				ccode_status="failed"
				echo -e "\nError: failed to parse the fetched file for country '$ccode'." >&2
				[[ "$retry_cnt" -ge "$fetch_retries" ]] && break
			else
				echo "Ok."
				# Validate the parsed list
				parsed_subnets_cnt=$(wc -l <<< "$parsed_list")

				echo -n "Validating... "
				validated_file="/tmp/validated-$ccode.tmp"
				grep -P "$subnet_regex" <<< "$parsed_list" > "$validated_file"
				unset parsed_list

				validated_subnets_cnt=$(wc -l < "$validated_file")

				failed_subnets_cnt=$(( parsed_subnets_cnt - validated_subnets_cnt ))
				if [[ "$failed_subnets_cnt" -gt 0 ]]; then
					echolog -err "Note: Fetch attempt $retry_cnt for country '$ccode': $failed_subnets_cnt subnets failed validation."
					[[ "$retry_cnt" -ge "$fetch_retries" ]] && { ccode_status="partial"; break; }
					rm "$validated_file" &>/dev/null
				else
					echo "Ok."
					ccode_status="Ok"
					break
				fi
			fi
		fi
		echo -e "Retrying fetch for country '$ccode'...\n"
	done

	if [[ "$ccode_status" = "Ok" || "$ccode_status" = "partial" ]] && [[ "$validated_subnets_cnt" -eq 0 ]]; then
		rm "$validated_file" &>/dev/null
		echolog "Error: validated 0 subnets for country '$ccode'. Perhaps the country code is incorrect?" >&2
		ccode_status="failed"
	fi

	# Check if subnets count decreased dramatically compared to the old list
	# This is to prevent a possible future situation where a regional registry server decides to change API or spew out wrong data
	# and we get something like 0 subnets, all successfully validated and passed as a good list
	if [[ "$old_list_exists" && "$ccode_status" != "up_to_date" ]]; then
		# compare fetched subnets count to old subnets count, get result in %
		subnets_percents="$(echo "scale=0 ; $validated_subnets_cnt * 100 / $old_subnets_cnt" | bc)"
		if [[ "$subnets_percents" -lt 90 ]]; then
			ccode_status="failed"
			rm "$validated_file" &>/dev/null
			echolog -err "Warning: validated subnets count '$validated_subnets_cnt' in the fetched list for country '$ccode'..."
			echolog -err "is ${subnets_percents}% of '$old_subnets_cnt' subnets in the existing list dated '$(date --date=@$date_old)'."
			echolog -err "Something is wrong! Not updating the list."
		else
			debugprint "Validated subnets count for country '$ccode' is ${subnets_percents}% of the count in the existing list"
		fi
	fi

	# If we have a partial list, decide whether to consider it Ok or not
	if [[ "$ccode_status" = "partial" ]]; then
			echolog -err "Warning: out of $parsed_subnets_cnt, $failed_subnets_cnt subnets for country '$ccode' failed validation."
			echolog -err "Invalid subnets removed from the list."

		if [[ "$old_list_exists" ]]; then
			## don't update the list if it is partial and the count of failed validations increased compared to the old list
			if [[ "$failed_subnets_cnt" -gt "$old_failed_subnets_cnt" ]]; then
				rm "$validated_file" &>/dev/null
				ccode_status="failed"
				err1="Warning: failed subnets count '$failed_subnets_cnt' for country '$ccode' is higher than '$old_failed_subnets_cnt' in the old list."
				err2="Not updating the list."
				echolog -err "$err1" "$err2"
			else
				ccode_status="Ok"
			fi
		else
			# old list does not exist
			# if we are in manual mode, meaning we were launched from either the *install or the *manage script
			if [[ "$manualmode" ]]; then
				# if an older existing list is unavailable, ask the user what to do
				echo -e "\n\nWarning: Ip list for country '$ccode' has been fetched but may be incomplete, and there is no older downloaded file for this list."
				echo "Use the incomplete list anyway?"
				while true; do
					read -p "(Y/N) " -n 1 -r
					if [[ "$REPLY" =~ ^[Yy]$ ]]; then ccode_status="Ok"; break
					elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
						ccode_status="failed"
						rm "$validated_file" &>/dev/null
					else echo -e "\nPlease press 'y/n'.\n"
					fi
				done
			fi
		fi
	fi

	echo

	if [[ "$ccode_status" = "Ok" ]]; then
		echo -e "Validated subnets count for country '$ccode': $validated_subnets_cnt.\n"
	fi

	case "$ccode_status" in
		Ok | up_to_date ) ;;

		partial | failed ) failed_ccodes="$failed_ccodes $ccode" ;;

		unknown ) echolog -err "Error: validation status for country '$ccode' is unknown. This should not happen. Please file a bug report." ;;
		* ) echolog -err "Error: validation status for country '$ccode' is '$ccode_status' which I don't understand. This should not happen. Please file a bug report." ;;
	esac

	if [[ "$ccode_status" = "Ok" ]]; then

		echo -n "Updating $list_path... "
		mv "$validated_file" "$list_path"; rv=$?
		if [[ $rv -ne 0 ]]; then
			echo "Failed."
			rm "$validated_file" &>/dev/null
			echolog -err "Failed to overwrite the file '$list_path'"
			failed_ccodes="$failed_ccodes $ccode"
		else
			echo "Ok."
			touch -d "$db_time" "$list_path"
			ccodes_to_update="$ccodes_to_update $ccode"
			failed_subnets_cnt_arr["$ccode"]="$failed_subnets_cnt"
		fi

	fi

	if [[ "$ccode_status" = "up_to_date" ]]; then
		up_to_date_ccodes="$up_to_date_ccodes $ccode"
		failed_subnets_cnt_arr["$ccode"]="$failed_subnets_cnt"
	fi

	rm "$validated_file" &>/dev/null
done

# report fetch results back to caller via status file
if [[ -n "$status_file" ]]; then
	# convert array contents to formatted string for writing to the status file
	for ccode in "${!failed_subnets_cnt_arr[@]}"; do

		# new line is intentional
		failed_subnets_cnt_str="$failed_subnets_cnt_str
LastFailedSubnetsCnt_${ccode}=${failed_subnets_cnt_arr[$ccode]}"
	done

#	debugprint "failed_subnets_cnt_str: '$failed_subnets_cnt_str'"

	setstatus "$status_file" "ccodes_to_update=$ccodes_to_update" "up_to_date_ccodes=$up_to_date_ccodes" "failed_ccodes=$failed_ccodes" "$failed_subnets_cnt_str" || \
		die "Error: Failed to write to the status file '$status_file'."
fi

#debugprint "status file contents:"
#[ "$debugmode" ] && { echo "'" >&2; cat "$status_file"; echo "'" >&2; }

debugexitmsg

exit 0
