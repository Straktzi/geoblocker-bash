#!/bin/bash -l

# geoblocker_bash-apply

# Loads or removes ipsets and iptables rules for the specified country code.

# Supported actions (specified by the -a option): add, remove

# 'geoblocker_bash-apply -a add -c <country_code>' :
#     Loads an ip list file for the specified country into an ipset
#     and sets iptables rules to only allow connections
#     from the local subnet and from subnets included in the ipset.

# 'geoblocker_bash-apply -a remove -c <country_code>' :
#     removes the ipset and associated iptables rules for the specified country.

# Requires the 'ipset' utility. To install it on Debian or derivatives, use the command:
## apt install ipset
#
# Requires root priviliges

me=$(basename "$0")
suite_name="geoblocker_bash"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[ -n "$script_dir" ] && cd "$script_dir" || { echo "Error: Couldn't cd into '$script_dir'."; exit 1; }

source "${suite_name}-common" || { echo "Error: Can't find ${suite_name}-common."; exit 1; }
# **NOTE** that some functions and variables are sourced from the *common script


#### USAGE

usage() {
    cat <<EOF

$me
    Loads or removes ipsets and iptables rules for the specified country code.
    Supported actions (specified by the -a option): add, remove.

    Usage: $me -a <add|remove> -c <country_code> [-p] [-d] [-t] [-h]

    Options:
        -a <action>       : action to perform: "add" or "remove" ipset and associated iptables rules
        -c <country_code> : tld / country code
        -p                : No Drop: applies the config but skips setting INPUT chain default policy to DROP
                                   (continue to accept all connections)

        -d                : Debug
        -t                : Simulate fault and test recovery
        -h                : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "a:c:pdht" opt; do
	case $opt in
		a) action=$OPTARG;;
		c) tld=$OPTARG;;
		p) nodrop="-p";;
		d) debug=true;;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo ""

# Print script enter message for debug
debugentermsg

#### FUNCTIONS

round_up_to_power2() {
# rounds the input number up to the next high power of 2
	echo "\
		if($1==0) x=0 else \
			x=l($1)/l(2); \
		scale=0; \
		y=2^((x+1)/1); \
		if($1==y/2 && $1!=1) \
			print $1 \
		else \
			print y"\
	 | bc -l
}


#### VARIABLES

# get datadir from the config file
datadir="$(getconfig "Datadir" "$conf_file")"

whitelist_dir="${datadir}/ip_lists"
whitelist_file="${whitelist_dir}/ipv4_${tld}"
perm_ipset="${suite_name}_${tld}"
temp_ipset="${perm_ipset}_temp"
iptables_comment="${suite_name}_${tld}"
iptables_comment_global="${suite_name}_global"
family="inet"


#### CHECKS

# check for country tld
if [ -z "$tld" ]; then
	usage
	die 254 "tld (country code) variable can not be empty!"
fi

# check for whitelist file path
if [ -z "$whitelist_file" ]; then
	usage
	die 254 "Error: whitelist file path can not be empty."
fi

# check for root
if [ "$EUID" -ne 0 ]; then
	die 254 "This needs to be run as root."
fi

# Check for ipset utility
if ! command -v "ipset" &> /dev/null; then
	die 254 "Error: Cannot find 'ipset'. Install it with 'apt install ipset' or similar."
fi

# Check for iptables-save utility
if ! command -v "iptables-save" &> /dev/null; then
	die 254"Error: Cannot find 'iptables-save'."
fi

# Check for bc utility
if ! command -v "bc" &> /dev/null; then
	die 254 "Error: Cannot find 'bc'."
fi

## check that we have the name for permanent ipset
if [ -z "$perm_ipset" ]; then
	die 254 "Error: ipset name can not be empty."
fi

# check that the whitelist file exists
if [ ! -f "$whitelist_file" ]; then
	die 254 "Error: Cannot find the whitelist file at path: '$whitelist_file'."
fi

case "$action" in
	add) ;;
	remove) ;;
	*) usage; die 254 "Error: unsupported action '$action'" ;;
esac


#### MAIN

if [ "$action" = "add" ]; then
	### Create a temporary ipset and load subnets from file into it

	# destroy temporary ipset in case it exists
	ipset destroy "$temp_ipset" &>/dev/null

	# count lines in the whitelist file
	ip_cnt=$(wc -l < "$whitelist_file")
#	debugprint "ip count in the whitelist file '$whitelist_file': $ip_cnt"

	# calculate necessary ipset size = (next high power of 2 > $ip_cnt)
	ipset_maxelem=$(round_up_to_power2 "$ip_cnt")
#	debugprint "calculated maxelem for ipset: $ipset_maxelem"

	# calculate hashsize = (512) or (ipset_maxelem / 32), whichever is larger
	testhashsize=$(echo "scale=0 ; $ipset_maxelem / 4" | bc)
#	debugprint "calculated hashsize: $testhashsize"
	if [ "$testhashsize" -lt 512 ]; then
		ipset_hashsize=512
	else
		ipset_hashsize="$testhashsize"
	fi
#	debugprint "final hashsize for the new ipset: $ipset_hashsize"

	# create new temporary ipset
	debugprint "Creating new ipset '$temp_ipset'... "
	ipset create "$temp_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
	if [ $rv -ne 0 ]; then
		die 254 "Error creating ipset '$temp_ipset' with hashsize $ipset_hashsize and maxelem $ipset_maxelem."
	fi
	debugprint "Ok."

	# import the whitelist into temporary ipset from file
	echo -n "Importing the whitelist for country '$tld' into temporary ipset... "

	# reads $whitelist_file, transforms each line into ipset add command and redirects the result into "ipset restore"
	# this is about 50x faster than issuing discrete "ipset add" commands in a loop
	# the '-exist' option prevents the restore command from getting stuck when encountering duplicates
	while read -r network; do \
		echo "add $temp_ipset $network"; \
	done < "$whitelist_file" |\
		ipset restore -exist; rv=$?

	if [ $rv -ne 0 ]; then
		echo ""
		ipset destroy "$temp_ipset"
		die 254 "Error when importing the list from '$whitelist_file' into '$temp_ipset'."
	fi

	echo "Ok."

	[ "$debug" ] && ipset_lines_cnt="$(ipset save "$temp_ipset" | grep "add $temp_ipset" | wc -l)"
	debugprint "subnets in the temporary ipset: $ipset_lines_cnt"
fi

### Remove existing geoblocker rules for iptables

## Temporarily set the policy for the INPUT chain to ACCEPT, in order to prevent user lock out in case of an error
echo -n "Setting INPUT chain policy to ACCEPT... "
iptables -P INPUT ACCEPT; rv=$?
if [ $rv -ne 0 ]; then
	die 254 "Error trying to change iptables policy with command 'iptables -P INPUT ACCEPT'."
fi
echo "Ok."

## delete existing iptables rules matching comment "$iptables_comment" and "$iptables_comment_global" which we use to mark our rules

echo -n "Removing existing iptables rules for country '$tld'... "

# sed looks for rules with the comment which we use to stamp our rules
# sed executes iptables -D (delete) command on matching rules. execution is promtped by the switch /e (only available in GNU sed)
iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null; rv=$?
if [ $rv -ne 0 ]; then
	echo "Failure."
	die "Error removing existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e\"."
fi
echo "Ok."

echo -n "Removing existing global iptables rules for '${suite_name}'... "
iptables-save | sed -r "/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e" &>/dev/null; rv=$?
if [ $rv -ne 0 ]; then
	echo "Failure."
	die "Error removing existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e\"."
fi
echo "Ok."

if [ "$action" = "remove" ]; then
	echo -n "Destroying ipset for country '$tld'... "
	ipset destroy "$perm_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Failure."
		die "Error destroying ipset $perm_ipset."
	else
		echo "Ok."
	fi
fi



### Create new iptables rules

# Add rule to allow connections from the local subnet
localsubnet="$(getlocalsubnet)";
if [ -z "$localsubnet" ]; then
	die "Error: couldn't determine local subnet."
else
	echo "Found local subnet: '$localsubnet'."
	echo -n "Appending rule to allow all traffic from the local subnet... "
	iptables -A INPUT -s "$localsubnet" -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to append rule with command 'iptables -A INPUT -s \"$localsubnet\" -j ACCEPT'."
	fi
	echo "Ok."
fi

echo -n "Inserting rule to allow all traffic from the loopback interface... "
iptables -I INPUT -i lo -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
if [ $rv -ne 0 ]; then
	die "Failed to insert rule with command 'iptables -A INPUT -i lo -j ACCEPT'."
fi
echo "Ok."


echo -n "Inserting rule to allow established/related connections... "
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
if [ $rv -ne 0 ]; then
	die "Failed to insert rules with command 'iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT'."
fi
echo "Ok."

if [ "$action" = "add" ]; then
	## check if permanent ipset already exists and is non-empty

	ipset_length=$(ipset -L "$perm_ipset" 2>/dev/null |  wc -l)

	if [ "$ipset_length" -ge "7" ]; then
		perm_ipset_exists="true"
		debugprint "found existing permanent ipset '$perm_ipset'."
	else
		perm_ipset_exists="false"
	fi

	if [ "$ipset_length" -eq 0 ]; then
		debugprint "Ipset '$perm_ipset' doesn't exist yet."
		# to avoid being dependent on ipset output staying constant down the road,
		# still trying to destroy the ipset, just in case, but not checking the return value
		ipset destroy "$perm_ipset" &>/dev/null
	fi

	## if permanent ipset doesn't exist yet, create it
	if [ ! "$perm_ipset_exists" = "true" ]; then
		# create new permanent ipset
		debugprint "Creating permanent ipset '$perm_ipset'... "
		ipset create "$perm_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
		if [ $rv -ne 0 ]; then
			die "Failed to create ipset '$perm_ipset' with hashsize $ipset_hashsize and maxelem $ipset_maxelem."
		else
			debugprint "Ok."
		fi
	fi

	## append the whitelist rule to the INPUT chain

	echo -n "Appending the whitelist rule to the INPUT chain... "
	iptables -A INPUT -m set --match-set "$perm_ipset" src -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to append ipset rules with command: iptables -I INPUT -m set --match-set \"$perm_ipset\" src -j ACCEPT."
	fi
	echo "Ok."

	## swap new (temporary) ipset with old (permanent) ipset
	echo -n "Making the new ipset permanent... "
	ipset swap "$temp_ipset" "$perm_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to swap temporary and permanent ipsets."
	fi
	echo "Ok."

	## destroy the old ipset (now it's called temporary)
	debugprint "Destroying temporary ipset... "
	ipset destroy "$temp_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to destroy ipset '$temp_ipset'. Strange........."
	fi
	debugprint "Ok."
fi

## configure iptables policies

if [ -z "$nodrop" ]; then
	# set policy on INPUT and FORWARD chains to DROP
	echo -n "Setting default iptables policies for INPUT and FORWARD to DROP... "
	iptables -P INPUT DROP; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to change iptables policy with command 'iptables -P INPUT DROP'."
	fi

	iptables -P FORWARD DROP; rv=$?
	if [ $rv -ne 0 ]; then
		die "Failed to change iptables policy with command 'iptables -P FORWARD DROP'."
	fi
	echo "Ok."
else
	echo "WARNING: nodrop was requested. Leaving INPUT and FORWARD chains with ACCEPT policies (geoblocking is inactive)."
fi

# This line is to simulate a simple fault and test recovery from backup
# Activates when running the script with the -t switch
[ $test ] && die "Test test test"


echo ""
case "$action" in
	add) completed_action="added";;
	remove) completed_action="removed";;
esac
echo "Successfully $completed_action iplist for country '$tld'."
echo ""

debugexitmsg

exit 0
