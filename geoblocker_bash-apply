#!/bin/bash -l

# geoblocker_bash-apply

# Loads or removes ipsets and iptables rules for the specified country code.

# Supported actions (specified by the -a option): add, remove

# 'geoblocker_bash-apply -a add -c <country_code>' :
#     Loads an ip list file for the specified country into an ipset
#     and sets iptables rules to only allow connections
#     from the local subnet and from subnets included in the ipset.

# 'geoblocker_bash-apply -a remove -c <country_code>' :
#     removes the ipset and associated iptables rules for the specified country.

# Requires the 'ipset' utility. To install it on Debian or derivatives, use the command:
## apt install ipset
#
# Requires root priviliges

me=$(basename "$0")
parent_script="$(ps -o args= $PPID | awk -v RS='/| ' '/^geoblocker/')"
args="$*"

#### USAGE

usage() {
    cat <<EOF

$me
    Loads or removes ipsets and iptables rules for the specified country code.
    Supported actions (specified by the -a option): add, remove.

    Usage: $me -a <add|remove> -c <country_code> [-p] [-d] [-t] [-h]

    Options:
        -a <action>       : action to perform: "add" or "remove" ipset and associated iptables rules
        -c <country_code> : tld / country code
        -p                : No Drop: applies the config but skips setting INPUT chain default policy to DROP
                                   (continue to accept all connections)

        -d                : Debug
        -t                : Simulate fault and test recovery
        -h                : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "a:c:pdht" opt; do
	case $opt in
		a) action=$OPTARG;;
		c) tld=$OPTARG;;
		p) nodrop="-p";;
		d) debug=true;;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo ""


#### FUNCTIONS

# prints a debug message
debugprint() {
	[ "$debug" ] && echo -e "    Debug: $*"
}

echo ""
debugprint "\033[1;33mStarted *apply with args: '$args'\033[0m"

die() {
# echo out the error passed in 1st argument and write it to syslog
	echo ""
	echo "$1" 1>&2
	echo ""
	logger -t geoblocker_bash-apply "$1"

	# if "nonfatal" wasn't specified in 2nd argument, exit with return code 1 (fatal); otherwise exit with code 254 (non-fatal)
	if [ "$2" != "nonfatal" ]; then
		[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"
		exit 1
	else
		exit 254
	fi
}

round_up_to_power2() {
# rounds the input number up to the next high power of 2
	echo "\
		if($1==0) x=0 else \
			x=l($1)/l(2); \
		scale=0; \
		y=2^((x+1)/1); \
		if($1==y/2 && $1!=1) \
			print $1 \
		else \
			print y"\
	 | bc -l
}

getconfig() {
# reads a field named $1 from the config file $2
# outputs the resulting field
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	if [ -z "$fieldname" ] || [ -z "$configfile" ]; then return 1; fi
	read -r field < <(grep "$fieldname=" "$configfile" | sed "s/.*$fieldname=//"); rv=$?
	if [ -z "$field" ]; then
		echo ""
		rv=$((rv + 1))
	else
		echo "$field"
	fi
	return $rv
}

getlocalsubnet() {
# attempts to find local subnet for the main network interface

	# regex patterns used for ipv4 validation
	# using Perl regex syntax because grep is faster with it than with native grep syntax
	# regex compiled from 2 suggestions found here:
	# https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp
	ip_regex='^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'
	mask_regex='(/([01]?\d\d?|2[0-4]\d|25[0-5]))$'
	subnet_regex="${ip_regex}${mask_regex}"

	# returns local ip with subnet mask
	localip="$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}')"

	# Change last ipv4 octet to 0
	lsubnet=$(echo "$localip" | sed 's|\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*|\10|')

	# Verifies that the argument is a valid ipv4 subnet
	echo "$lsubnet" | grep -P "$subnet_regex" &>/dev/null; rv=$?

	if [ $rv -ne 0 ]; then
		# if validation fails, output empty string
		echo ""
	else
		echo "$lsubnet"
	fi
	return $rv
}


#### VARIABLES

conf_dir="/etc/geoblocker_bash"
conf_file="${conf_dir}/geoblocker_bash.conf"

# read datadir from the config file
read -r datadir < <(getconfig "Datadir" "$conf_file")

whitelist_dir="${datadir}/ip_lists"
whitelist_file="${whitelist_dir}/ipv4_${tld}"
perm_ipset="geoblocker_bash_${tld}"
temp_ipset="${perm_ipset}_temp"
iptables_comment="geoblocker_bash_${tld}"
iptables_comment_global="geoblocker_bash_global"
family="inet"


#### CHECKS

# check for country tld
if [ -z "$tld" ]; then
	usage
	die "tld (country code) variable can not be empty! Exiting." "nonfatal"
fi

# check for whitelist file path
if [ -z "$whitelist_file" ]; then
	usage
	die "Error: whitelist file path can not be empty. Exiting." "nonfatal"
fi

# check for root
if [ "$EUID" -ne 0 ]; then
	die "This needs to be run as root." "nonfatal"
fi

# Check for ipset utility
if ! command -v "ipset" &> /dev/null; then
	die "Error: Cannot find 'ipset'. Install it with 'apt install ipset' or similar. Exiting." "nonfatal"
fi

# Check for iptables-save utility
if ! command -v "iptables-save" &> /dev/null; then
	die "Error: Cannot find 'iptables-save'. Exiting." "nonfatal"
fi

# Check for bc utility
if ! command -v "bc" &> /dev/null; then
	die "Error: Cannot find 'bc'. Exiting." "nonfatal"
fi

## check that we have the name for permanent ipset
if [ -z "$perm_ipset" ]; then
	die "Error: ipset name can not be empty. Exiting." "nonfatal"
fi

# check that the whitelist file exists
if [ ! -f "$whitelist_file" ]; then
	die "Error: Cannot find the whitelist file at path: '$whitelist_file'. Exiting." "nonfatal"
fi

case "$action" in
	add) ;;
	remove) ;;
	*) usage; echo "Error: unsupported action '$action'" "nonfatal" ;;
esac


#### MAIN

if [ "$action" = "add" ]; then
	### Create a temporary ipset and load subnets from file into it

	# destroy temporary ipset in case it exists
	ipset destroy "$temp_ipset" &>/dev/null

	# count lines in the whitelist file
	ip_cnt=$(wc -l < "$whitelist_file")
	debugprint "ip count in the whitelist file '$whitelist_file': $ip_cnt"

	# calculate necessary ipset size = (next high power of 2 > $ip_cnt)
	ipset_maxelem=$(round_up_to_power2 "$ip_cnt")
	debugprint "calculated maxelem for ipset: $ipset_maxelem"

	# calculate hashsize = (512) or (ipset_maxelem / 32), whichever is larger
	testhashsize=$(echo "scale=0 ; $ipset_maxelem / 4" | bc)
	debugprint "calculated hashsize: $testhashsize"
	if [ "$testhashsize" -lt 512 ]; then
		ipset_hashsize=512
	else
		ipset_hashsize="$testhashsize"
	fi
	debugprint "final hashsize for the new ipset: $ipset_hashsize"

	# create new temporary ipset
	debugprint "Creating new ipset '$temp_ipset'... "
	ipset create "$temp_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error creating ipset '$temp_ipset' with hashsize $ipset_hashsize and maxelem $ipset_maxelem. Exiting." "nonfatal"
	fi
	debugprint "Ok."

	# import the whitelist into temporary ipset from file
	echo -n "Importing the whitelist for country '$tld' into temporary ipset... "

	# reads $whitelist_file, transforms each line into ipset add command and redirects the result into "ipset restore"
	# this is about 50x faster than issuing discrete "ipset add" commands in a loop
	# the '-exist' option prevents the restore command from getting stuck when encountering duplicates
	while read -r network; do \
		echo "add $temp_ipset $network"; \
	done < "$whitelist_file" |\
		ipset restore -exist; rv=$?

	if [ $rv -ne 0 ]; then
		echo ""
		ipset destroy "$temp_ipset"
		die "Error when importing the list from '$whitelist_file' into '$temp_ipset'. Exiting." "nonfatal"
	fi

	echo "Ok."

	[ $debug ] && read -r ipset_lines < <(ipset save "$temp_ipset" | grep "add $temp_ipset" | wc -l)
	debugprint "ip's in the temporary ipset: $ipset_lines"
fi

### Remove existing geoblocker rules for iptables

## Temporarily set the policy for the INPUT chain to ACCEPT, in order to prevent user lock out in case of an error
echo -n "Setting INPUT chain policy to ACCEPT... "
iptables -P INPUT ACCEPT; rv=$?
if [ $rv -ne 0 ]; then
	die "Error trying to change iptables policy with command 'iptables -P INPUT ACCEPT'. Exiting." "nonfatal"
fi
echo "Ok."

## delete existing iptables rules matching comment "$iptables_comment" and "$iptables_comment_global" which we use to mark our rules

echo -n "Removing existing iptables rules for country '$tld'... "

# sed looks for rules with the comment which we use to stamp our rules
# sed executes iptables -D (delete) command on matching rules. execution is promtped by the switch /e (only available in GNU sed)
iptables-save | sed -r "/INPUT.*comment.*${iptables_comment}/s/-A/iptables -D/e" &>/dev/null; rv=$?
if [ $rv -ne 0 ]; then
	echo "Failure."
	die "Error removing existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e\". Exiting."
fi
echo "Ok."

echo -n "Removing existing global iptables rules for 'geoblocker_bash'... "
iptables-save | sed -r "/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e" &>/dev/null; rv=$?
if [ $rv -ne 0 ]; then
	echo "Failure."
	die "Error removing existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*${iptables_comment_global}/s/-A/iptables -D/e\". Exiting."
fi
echo "Ok."

if [ "$action" = "remove" ]; then
	echo -n "Destroying ipset for country '$tld'... "
	ipset destroy "$perm_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		echo "Failure."
		die "Error destroying ipset $perm_ipset. Exiting."
	else
		echo "Ok."
	fi
fi



### Create new iptables rules

# Add rule to allow connections from the local subnet
localsubnet="$(getlocalsubnet)";
if [ -z "$localsubnet" ]; then
	die "Error: couldn't determine local subnet."
else
	echo "Found local subnet: '$localsubnet'."
	echo -n "Appending rule to allow all traffic from the local subnet... "
	iptables -A INPUT -s "$localsubnet" -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error $rv trying to append rule with command 'iptables -A INPUT -s \"$localsubnet\" -j ACCEPT'. Exiting."
	fi
	echo "Ok."
fi

echo -n "Inserting rule to allow all traffic from the loopback interface... "
iptables -I INPUT -i lo -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
if [ $rv -ne 0 ]; then
	die "Error $rv trying to insert rules with command 'iptables -A INPUT -i lo -j ACCEPT'. Exiting."
fi
echo "Ok."


echo -n "Inserting rule to allow established/related connections... "
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "${iptables_comment_global}"; rv=$?
if [ $rv -ne 0 ]; then
	die "Error $rv trying to insert rules with command 'iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT'. Exiting."
fi
echo "Ok."

if [ "$action" = "add" ]; then
	## check if permanent ipset already exists and is non-empty

	ipset_length=$(ipset -L "$perm_ipset" 2>/dev/null |  wc -l)

	if [ "$ipset_length" -ge "7" ]; then
		perm_ipset_exists="true"
		debugprint "found existing permanent ipset '$perm_ipset'."
	else
		perm_ipset_exists="false"
	fi

	if [ "$ipset_length" -eq 0 ]; then
		debugprint "Ipset '$perm_ipset' doesn't exist yet."
		# to avoid being dependent on ipset output staying constant down the road,
		# still trying to destroy the ipset, just in case, but not checking the return value
		ipset destroy "$perm_ipset" &>/dev/null
	fi

	## if permanent ipset doesn't exist yet, create it
	if [ ! "$perm_ipset_exists" = "true" ]; then
		# create new permanent ipset
		debugprint "Creating permanent ipset '$perm_ipset'... "
		ipset create "$perm_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
		if [ $rv -ne 0 ]; then
			die "Error creating ipset '$perm_ipset' with hashsize $ipset_hashsize and maxelem $ipset_maxelem. Exiting."
		else
			debugprint "Ok."
		fi
	else
		debugprint "$perm_ipset already exists."
	fi

	## append the whitelist rule to the INPUT chain

	echo -n "Appending the whitelist rule to the INPUT chain... "
	iptables -A INPUT -m set --match-set "$perm_ipset" src -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error appending ipset rules with command: iptables -I INPUT -m set --match-set \"$perm_ipset\" src -j ACCEPT. Exiting."
	fi
	echo "Ok."

	## swap new (temporary) ipset with old (permanent) ipset
	echo -n "Making the new ipset permanent... "
	ipset swap "$temp_ipset" "$perm_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error swapping temporary and permanent ipsets. Exiting."
	fi
	echo "Ok."

	## destroy the old ipset (now it's called temporary)
	debugprint "Destroying temporary ipset... "
	ipset destroy "$temp_ipset"; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error $rv destroying ipset '$temp_ipset'. Strange......... Exiting."
	fi
	debugprint "Ok."
fi

## configure iptables policies

if [ -z "$nodrop" ]; then
	# set policy on INPUT and FORWARD chains to DROP
	echo -n "Setting default iptables policies for INPUT and FORWARD to DROP... "
	iptables -P INPUT DROP; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error $rv changing iptables policy with command 'iptables -P INPUT DROP'. Exiting."
	fi

	iptables -P FORWARD DROP; rv=$?
	if [ $rv -ne 0 ]; then
		die "Error $rv changing iptables policy with command 'iptables -P FORWARD DROP'. Exiting."
	fi
	echo "Ok."
else
	echo "WARNING: nodrop was requested. Leaving INPUT and FORWARD chains with ACCEPT policies (geoblocking is inactive)."
fi

# This line is to simulate a simple fault and test recovery from backup
# Activates when running the script with the -t switch
[ $test ] && die "Test test test"


echo ""
case "$action" in
	add) completed_action="added";;
	remove) completed_action="removed";;
esac
echo "Successfully $completed_action iplist for country '$tld'."
echo ""

[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"

exit 0
