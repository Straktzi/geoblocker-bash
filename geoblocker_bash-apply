#!/bin/bash -l

# geoblocker_bash-apply
#
# Loads a user-specified whitelist file into an ipset and sets iptables rules to only
#         allow connection from subnets included in the ipset
#
# If successful, creates backup of the current (known-good) iptables state and current ipset
#
# In case of an error, restores last known-good state from backup
#
# If that fails, the script assumes that something is broken and runs the uninstall script
#        which will remove any rules we have set, delete associated cron jobs
#        and restore policies for INPUT and FORWARD chains to the pre-install state
#
# Requires the 'ipset' utility. To install it on Debian or derivatives, use the command:
## apt install ipset
#
# Must be run as root
#
# For input, requires a plaintext file with ip subnet list in the format x[xx].x[xx].x[xx].x[xx]/x[xx]


me=$(basename "$0")

#### USAGE

usage() {
    cat <<EOF

This script:
1) Creates or updates an ipset from a user-specified whitelist file (which should contain a plain ipv4 subnets list).
2) Creates iptables rules that allow connection from subnets included in the ipset
3) Sets default policy on INPUT and FORWARD iptables chains to DROP
4) Creates backup of the current (known-good) iptables state and current ipset
5) In case of an error, attempts to restore last known-good state from backup
6) If that fails, the script assumes that something is broken and runs the uninstall script
        which will attempt to remove any rules we have set, delete the associated cron jobs
        and restore policies for INPUT and FORWARD chains to the pre-install state

    Usage: $me -f <file> -b <file> [-d] [-t] [-h]

    Options:
    -f <file>  : path to whitelist file containing raw subnets list in the format of xxx.xxx.xxx.xxx/xxx
    -b <file>  : path to file where a backup of last known-good iptables state will be saved

    -d         : Debug
    -t         : Simulate fault and test recovery
    -h         : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "f:b:dht" opt; do
	case $opt in
		f) whitelist_file=$OPTARG;;
		b) knowngood_file=$OPTARG;;
		d) debug=true;;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo ""

#### FUNCTIONS

knowngood_failed() {
	err1="$1"; err2="$2"
	echo ""
	echo "$err1" >&2; echo "$err2" >&2
	# print errors to syslog
	logger -t geoblocker_bash-apply "$err1"; logger -t geoblocker_bash-apply "$err2"
	geoblocker_bash-uninstall -p
	exit 1
}

restart_fail2ban() {
# fail2ban doesn't handle well flushing the INPUT chain then restoring iptables
# this function restarts fail2ban service after these operations in order to work around that issue
	systemctl is-enabled fail2ban &> /dev/null; rv=$?
	if [ $rv -eq 0 ]; then
		echo -n "Restarting fail2ban..." >&2
		systemctl restart fail2ban; rv=$?
		if [ $rv -eq 0 ]; then
			echo "Ok." >&2
		else
			echo "Failed." >&2
		fi
	fi
	echo ""
}

restore_from_file() {
# restores iptables and ipset state from a backup file
	restoretarget="$1"
	restorefile="$2"
	echo "Checking the $restoretarget portion of the backup file..."

	# count lines in the corresponding portion of the backup file
	case $restoretarget in
		iptables) line_cnt=$(sed -e '/\[IPSET\]/Q' "$restorefile" | wc -l) ;;
		ipset) line_cnt=$(sed -n "/create ${perm_ipset}/,\$p" "$restorefile" | grep "add $perm_ipset" | wc -l) ;;
	esac
	[ $debug ] && echo "Debug: $restoretarget lines number in backup: $line_cnt"

	if [ $line_cnt -gt 0 ]; then
		echo -n "Restoring $restoretarget state from backup... "

		case $restoretarget in
			# reads <$restorefile> from beginning to [IPSET] and pipes the result into iptables-restore
			iptables) sed -e '/\[IPSET\]/Q' "$restorefile" 2>&1 | iptables-restore; rv="${PIPESTATUS[1]}" ;;

			# reads <$restorefile> from "create <$perm_ipset>" to the end and pipes the result into "ipset restore"
			ipset) sed -n "/create ${perm_ipset}/,\$p" "$restorefile" 2>&1 | ipset restore; rv="${PIPESTATUS[1]}" ;;
		esac

		if [ $rv -eq 0 ]; then
			echo "Success."
			if [ "$restoretarget" = "iptables" ]; then restart_fail2ban; fi
			return 0
		else
			echo "Failure."
			err1="Failed to restore $restoretarget known-good state from backup."
		fi
	else
		err1="Error: $restoretarget backup appears to be empty or non-existing."
	fi

	# if we are here then something is seriously broken (unless the script ran in test mode with the -t switch)
	# run the uninstall script with -p switch to restore iptables to pre-install state but leave files in place
	err2="*** Reverting iptables to pre-install state and removing cron jobs ***"

	# if -t switch wasn't specified at launch then it's not a test
	if [ ! $test ]; then
		knowngood_failed "$err1" "$err2"
	else
		echo "$err1"
		echo "-t switch was specified, which means we are in test mode. Skipping uninstall."
		echo "WARNING: RECOVERY TEST FAILED AND GEOBLOCKER IS CURRENTLY INACTIVE"

		# still need to restart fail2ban if it's installed
		if [ "$restoretarget" = "iptables" ]; then
			restart_fail2ban
			exit 1
		fi
	fi
	echo ""; echo ""
}

restoreknowngood() {
# resets iptables policies and rules, destroys the whitelist ipset and then initiates restore from file
	restorefile="$1"

	echo ""; echo ""
	msg1="NOTE: Resetting iptables rules for Geoblocker... "
	echo "$msg1" >&2
	logger -t geoblocker_bash-apply  "$msg1"

	echo "Setting INPUT chain policy to ACCEPT... "
	iptables -P INPUT ACCEPT
	echo "Flushing the INPUT chain... "
	iptables -F INPUT
	echo "Destroying ipset $perm_ipset..."
	ipset destroy "$perm_ipset"

	echo ""
	msg1="NOTE: Restoring last known-good ipset and iptables from backup... "
	echo "$msg1" >&2
	echo "Backup file: $restorefile"
	echo ""

	restore_from_file "ipset" "$restorefile"
	restore_from_file "iptables" "$restorefile"
	msg1="Successfully restored known-good ipset and iptables state from backup."
	echo "$msg1"; echo ""
	logger -t geoblocker_bash-apply  "$msg1"
}

die() {
# echo out the error passed in 1st argument and write it to syslog
	echo ""
	echo "$1" 1>&2
	echo ""
	logger -t geoblocker_bash-apply "$1"

	# if "norestore" wasn't specified in 2nd argument, attempt to restore iptables and ipset from backup
	[ ! "$2" = "norestore" ] && restoreknowngood "$knowngood_file"
	exit 1
}

round_up_to_power2() {
# rounds the input number up to the next high power of 2
	echo "\
		if($1==0) x=0 else \
			x=l($1)/l(2); \
		scale=0; \
		y=2^((x+1)/1); \
		if($1==y/2 && $1!=1) \
			print $1 \
		else \
			print y"\
	 | bc -l
}

#### Initialize variables
perm_ipset="geoblocker_whitelist"
temp_ipset="${perm_ipset}_temp"
iptables_comment="geoblocker_bash"
family="inet"


#### Checks

# check that we have a path to the whitelist file
if [ -z "$whitelist_file" ]; then
	usage
	err="Error: whitelist file path can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# check that we have knowngood file path
if [ -z "$knowngood_file" ]; then
	usage
	err="Error: known-good file path can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# check for root
if [ "$EUID" -ne 0 ]; then
	err="This needs to be run as root."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the ipset utility
if ! command -v "ipset" &> /dev/null; then
	err="Error: Cannot find 'ipset'. Install it with 'apt install ipset' or similar. Exiting."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the iptables-save utility
if ! command -v "iptables-save" &> /dev/null; then
	err="Error: Cannot find 'iptables-save'. Exiting."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the iptables-restore utility
if ! command -v "iptables-restore" &> /dev/null; then
	err="Error: Cannot find 'iptables-restore'. Exiting."
	echo ""
	die "$err" "norestore"
fi

## check that we have the name for permanent ipset
if [ -z "$perm_ipset" ]; then
	err="Error: ipset name can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# check that the whitelist file exists
if [ ! -f "$whitelist_file" ]; then
	err="Error: Cannot find the whitelist file at path: \"$whitelist_file\". Exiting."
	echo ""
	die "$err" "norestore"
fi


#### Main

### Create a temporary ipset and load subnets from file into it

# destroy temporary ipset in case it exists
ipset destroy "$temp_ipset" &>/dev/null

# count lines in the whitelist file
ip_cnt=$(wc -l < "$whitelist_file")
[ $debug ] && echo "Debug: ip count in the whitelist file: $ip_cnt"

# calculate necessary ipset size = (next high power of 2 > $ip_cnt)
ipset_maxelem=$(round_up_to_power2 "$ip_cnt")
[ $debug ] && echo "Debug: calculated maxelem for ipset: $ipset_maxelem"

# calculate hashsize = (512) or (ipset_maxelem / 32), whichever is larger
testhashsize=$(echo "scale=0 ; $ipset_maxelem / 32" | bc)
[ $debug ] && echo "Debug: calculated hashsize: $testhashsize"
if [ "$testhashsize" -lt 512 ]; then
	ipset_hashsize=512
else
	ipset_hashsize="$testhashsize"
fi
[ $debug ] && echo "Debug: final hashsize for the new ipset: $ipset_hashsize"

# create new temporary ipset
[ $debug ] && echo -n "Creating new ipset \"$temp_ipset\"... "
ipset create "$temp_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error creating ipset \"$temp_ipset\" with hashsize $ipset_hashsize and maxelem $ipset_maxelem. Exiting."
	echo ""
	die "$err"
fi
[ $debug ] && echo "Ok."

# import the whitelist into temporary ipset from file
echo -n "Importing the whitelist file into temporary ipset... "

while IFS= read -r ip
do
	ipset add "$temp_ipset" "$ip"; rv=$?
	if [ $rv -ne 0 ]; then
		err="Error when running the command: \"ipset add $perm_ipset $ip\". Exiting."
		echo ""
		die "$err"
	fi
done < "$whitelist_file"

echo "Ok."

[ $debug ] && ipset_lines=$(ipset save "$temp_ipset" | grep "add $temp_ipset" | wc -l)
[ $debug ] && echo "Debug: ip's in the temporary ipset: $ipset_lines"


### Remove existing geoblocker rules for iptables before creating new rules

## Temporarily set the policy for the INPUT chain to ACCEPT, in order to prevent user lock out in case of an error
echo -n "Setting INPUT chain policy to ACCEPT... "
iptables -P INPUT ACCEPT; rv=$?
if [ $rv -ne 0 ]; then
	err="Error trying to change iptables policy with command \"iptables -P INPUT ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## delete existing iptables rules matching comment "$iptables_comment" which we use to mark our rules

echo -n "Removing existing iptables rules for geoblocker_bash... "

# sed looks for rules with the comment which we use to stamp our rules
# sed executes iptables -D (delete) command on matching rules. execution is promtped by the switch /e (only available in GNU sed)
iptables-save | sed -r "/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e" &>/dev/null; rv=$?

if [ $rv -ne 0 ]; then
	echo "Failure."
	err="Error removing existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."


### Create new iptables rules

echo -n "Inserting rule to allow all traffic from the loopback interface... "
iptables -I INPUT -i lo -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to insert rules with command \"iptables -A INPUT -i lo -j ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."


echo -n "Inserting rule to allow established/related connections... "
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to insert rules with command \"iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."


## check if permanent ipset already exists and is non-empty

ipset_length=$(ipset -L "$perm_ipset" 2>/dev/null |  wc -l)

if [ "$ipset_length" -ge "7" ]; then
	perm_ipset_exists="true"
	[ $debug ] && echo "Debug: found existing permanent ipset \"$perm_ipset\"."
else
	perm_ipset_exists="false"
fi

if [ "$ipset_length" -eq 0 ]; then
	[ $debug ] && echo "Debug: Ipset \"$perm_ipset\" doesn't exist yet."
	# to avoid being dependent on ipset output staying constant down the road,
	# still trying to destroy the ipset, just in case, but not checking the return value
	ipset destroy "$perm_ipset" &>/dev/null
fi

## if permanent ipset doesn't exist yet, create it
if [ ! "$perm_ipset_exists" = "true" ]; then
	# create new permanent ipset
	[ $debug ] && echo -n "Creating permanent ipset \"$perm_ipset\"... "
	ipset create "$perm_ipset" hash:net family "$family" hashsize "$ipset_hashsize" maxelem "$ipset_maxelem"; rv=$?
	if [ $rv -ne 0 ]; then
		err="Error creating ipset \"$perm_ipset\" with hashsize $ipset_hashsize and maxelem $ipset_maxelem. Exiting."
		echo ""
		die "$err"
	else
		[ $debug ] && echo "Ok."
	fi
else
	[ $debug ] && echo "Debug: $perm_ipset already exists."
fi

## append the whitelist rule to the INPUT chain

echo -n "Appending the whitelist rule to the INPUT chain... "
iptables -A INPUT -m set --match-set "$perm_ipset" src -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error appending ipset rules with command: iptables -I INPUT -m set --match-set \"$perm_ipset\" src -j ACCEPT. Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## swap new (temporary) ipset with old (permanent) ipset
echo -n "Making the new ipset permanent... "
ipset swap "$temp_ipset" "$perm_ipset"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error swapping temporary and permanent ipsets. Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## destroy the old ipset (now it's called temporary)
[ $debug ] && echo -n "Destroying temporary ipset... "
ipset destroy "$temp_ipset"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv destroying ipset \"$temp_ipset\". Strange......... Exiting."
	echo ""
	die "$err"
fi
[ $debug ] && echo "Ok."


## configure iptables policies

# set policy on INPUT and FORWARD chains to DROP
echo -n "Setting default iptables policies for INPUT and FORWARD to DROP... "
iptables -P INPUT DROP; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv changing iptables policy with command \"iptables -P INPUT DROP\". Exiting."
	echo ""
	die "$err"
fi

iptables -P FORWARD DROP; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv changing iptables policy with command \"iptables -P FORWARD DROP\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

# This line is to simulate a simple fault and test recovery from backup
# Activates when running the script with the -t switch
[ $test ] && die "Test test test"


### Create backup file for known-good iptables state and save current state to the file

echo -n "Creating backup of current iptables state... "
touch "$knowngood_file.new"

iptables-save > "$knowngood_file.new"; rv=$?
if [ $rv -ne 0 ]; then
	echo ""
	err="Error creating backup of iptables state with command: iptables-save > \"$knowngood_file.new\". Exiting." >&2
	die "$err"
fi
echo "Ok."

echo -n "Creating backup of current ipset... "

# we use the same file for iptables and ipset backup
# the "[IPSET]" line separates the two portions of the file
echo "[IPSET]" >> "$knowngood_file.new"

ipset save "$perm_ipset" >> "$knowngood_file.new"; rv=$?
if [ $rv -ne 0 ]; then
	echo ""
	err="Error creating backup of ipset \"$perm_ipset\". Exiting."
	die "$err"
fi
echo "Ok."

echo "Backup file: \"$knowngood_file\""

mv "$knowngood_file.new" "$knowngood_file"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error overwriting backup file for ipset and iptables state. Exiting." >&2
	die "$err"
fi

echo ""
echo "Successfully applied new iptables rules."
echo ""
