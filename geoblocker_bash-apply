#!/bin/bash -l

# geoblocker_bash-apply
#
# Creates or updates an ipset from a user-specified whitelist file (which should contain a plain ipv4 subnets list).
# Creates iptables rules that allow connection from subnets included in the ipset
# Sets default policy on INPUT and FORWARD iptables chains to DROP
# Creates backup of the current (known-good) iptables state and current ipset
# In case of an error, attempts to restore last known-good state from backup
# If that fails, the script assumes that something is broken and runs the uninstall script
#        which will attempt to remove any rules we have set, delete associated cron jobs
#        and restore policies for INPUT and FORWARD chains to the pre-install state
#
# Requires the 'ipset' utility. To install it on Debian or derivatives, use the command:
## apt install ipset
#
# For input, requires a plaintext file with ip subnet list in the format xxx.xxx.xxx.xxx/xxx


me=$(basename "$0")

#### USAGE

usage() {
    cat <<EOF

This script:
1) Creates or updates an ipset from a user-specified whitelist file (which should contain a plain ipv4 subnets list).
2) Creates iptables rules that allow connection from subnets included in the ipset
3) Sets default policy on INPUT and FORWARD iptables chains to DROP
4) Creates backup of the current (known-good) iptables state and current ipset
5) In case of an error, attempts to restore last known-good state from backup
6) If that fails, the script assumes that something is broken and runs the uninstall script
        which will attempt to remove any rules we have set, delete the associated cron jobs
        and restore policies for INPUT and FORWARD chains to the pre-install state

    Usage: $me -p path -k path [-d] [-t] [-h]

    Options:
    -p path    : path to whitelist file containing raw subnets list in the format of xxx.xxx.xxx.xxx/xxx
    -k path    : path to file where last known-good iptables state will be saved

    -d         : Debug
    -t         : Simulate fault and test recovery
    -h         : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "p:k:dht" opt; do
	case $opt in
		p) whitelist_path=$OPTARG;;
		k) knowngood_file=$OPTARG;;
		d) debug=true;;
		h) usage; exit 0;;
		t) test=true;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))

echo ""

#### FUNCTIONS

knowngood_failed() {
	err1="$1"; err2="$2"
	echo ""
	echo "$err1" >&2; echo "$err2" >&2
	# print errors to syslog
	logger -t geoblocker_bash-apply "$err1"; logger -t geoblocker_bash-apply "$err2"
	geoblocker_bash-uninstall -p
	exit 1
}

restart_fail2ban() {
# fail2ban doesn't handle well flushing the INPUT chain then restoring iptables
# this function restarts fail2ban service after these operations in order to work around that issue
	systemctl is-enabled fail2ban &> /dev/null; rv=$?
	if [ $rv -eq 0 ]; then
		echo -n "Restarting fail2ban..." >&2
		systemctl restart fail2ban; rv=$?
		if [ $rv -eq 0 ]; then
			echo "Ok." >&2
		else
			echo "Failed." >&2
		fi
	fi
	echo ""
}

restore_from_file() {
	restoretarget="$1"
	restorefile="$2"
	echo "Checking the $restoretarget portion of the backup file..."
	
	# count lines in the corresponding portion of the backup file
	case $restoretarget in
		iptables) line_cnt=$(sed -e '/\[IPSET\]/Q' $restorefile | wc -l) ;;
		ipset) line_cnt=$(sed -n "/create ${ipset_name}/,\$p" "$restorefile" | wc -l) ;;
	esac
	[ $debug ] && echo "Debug: $restoretarget lines number in backup: $line_cnt"

	if [ $line_cnt -gt 0 ]; then
		echo -n "Restoring $restoretarget state from backup... "

		case $restoretarget in
			# reads <$restorefile> from beginning to [IPSET] and pipes the result into iptables-restore
			iptables) sed -e '/\[IPSET\]/Q' "$restorefile" 2>&1 | iptables-restore; rv="${PIPESTATUS[1]}" ;;

			# reads <$restorefile> from "create <$ipset_name>" to the end and pipes the result into "ipset restore"
			ipset) sed -n "/create ${ipset_name}/,\$p" "$restorefile" 2>&1 | ipset restore; rv="${PIPESTATUS[1]}" ;;
		esac
		
		if [ $rv -eq 0 ]; then
			echo "Success."
			if [ $restoretarget = "iptables" ]; then restart_fail2ban; fi
			return 0
		else
			echo "Failure."
			err1="Failed to restore $restoretarget known-good state from backup."
		fi
	else
		err1="Error: $restoretarget backup appears to be empty or non-existing."
	fi

	# if we are here then something is seriously broken (unless the script ran in test mode with the -t switch)
	# run the uninstall script with -p switch to restore iptables to pre-install state but leave files in place
	err2="*** Rolling back all changes made to $restoretarget to pre-install state and removing cron jobs ***"
	
	# if -t switch wasn't specified at launch then it's not a test. proceed to 2nd stage of fault recovery.
	if [ ! $test ]; then
		knowngood_failed "$err1" "$err2"
	else
		echo "$err1"
		echo "-t switch was specified, which means we are in test mode. Skipping uninstall."
		echo "WARNING: RECOVERY TEST FAILED AND GEOBLOCKER IS CURRENTLY INACTIVE"
		
		# still need to restart fail2ban if it's installed
		if [ $restoretarget = "iptables" ]; then
			restart_fail2ban
			exit 1
		fi
	fi
	echo ""; echo ""
}

restoreknowngood() {
	restorefile="$1"

	echo ""; echo ""
	msg1="NOTE: Resetting iptables rules for Geoblocker... "
	echo "$msg1" >&2
	logger -t geoblocker_bash-apply  "$msg1"

	echo "Setting INPUT chain policy to ACCEPT... "
	iptables -P INPUT ACCEPT
	echo "Flushing the INPUT chain... "
	iptables -F INPUT
	echo "Destroying ipset $ipset_name..."
	ipset destroy "$ipset_name"

	echo ""
	msg1="NOTE: Restoring last known-good ipset and iptables from backup... "
	echo "$msg1" >&2
	echo "Backup file: $restorefile"
	echo ""
	
	restore_from_file "ipset" "$restorefile"
	restore_from_file "iptables" "$restorefile"
	msg1="Successfully restored known-good ipset and iptables state from backup."
	echo "$msg1"; echo ""
	logger -t geoblocker_bash-apply  "$msg1"
}

die() {
	# echo out the error passed in 1st argument and write it to syslog
	echo ""
	echo "$1" 1>&2
	echo ""
	logger -t geoblocker_bash-apply "$1"

	# if "norestore" wasn't specified in 2nd argument, attempt to restore iptables and ipset from backup
	[ ! "$2" = "norestore" ] && restoreknowngood "$knowngood_file"
	exit 1
}

#### Initialize variables
ipset_name="geoblocker_whitelist"
iptables_comment="geoblocker_bash"
family="inet"


#### Checks

# check that we have whitelist file path
if [ -z "$whitelist_path" ]; then
	usage
	err="Error: whitelist file path can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# check that we have knowngood file path
if [ -z "$knowngood_file" ]; then
	usage
	err="Error: known-good file path can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the ipset utility
if ! command -v "ipset" &> /dev/null; then
	err="Error: Cannot find 'ipset'. Install it with 'apt install ipset' or similar. Exiting."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the iptables-save utility
if ! command -v "iptables-save" &> /dev/null; then
	err="Error: Cannot find 'iptables-save'. Exiting."
	echo ""
	die "$err" "norestore"
fi

# Check that we have the iptables-restore utility
if ! command -v "iptables-restore" &> /dev/null; then
	err="Error: Cannot find 'iptables-restore'. Exiting."
	echo ""
	die "$err" "norestore"
fi

## check that we have ipset_name
if [ -z "$ipset_name" ]; then
	err="Error: ipset name can not be empty. Exiting."
	echo ""
	die "$err" "norestore"
fi

# check that the whitelist file exists
if [ ! -f "$whitelist_path" ]; then
	err="Error: Cannot find the whitelist file at path: \"$whitelist_path\". Exiting."
	echo ""
	die "$err" "norestore"
fi


#### Main

## Temporarily set the policy for the INPUT chain to ACCEPT, in order to prevent user lock out in case of an error
echo -n "Temporarily setting INPUT chain policy to ACCEPT... "
iptables -P INPUT ACCEPT; rv=$?
if [ $rv -ne 0 ]; then
	err="Error trying to change iptables policy with command \"iptables -P INPUT ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## delete existing iptables rules matching comment "$iptables_comment" which we use to mark our rules

echo -n "Removing existing iptables rules for geoblocker_bash... "

# iptables-save command dumps the table to stdout, then we pipe the contents into sed
# sed looks for rules with the comment $iptables_comment which we use to stamp our rules
# sed executes iptables -D (delete) command on matching rules. execution is promtped by the switch /e (only available in GNU sed)
iptables-save | sed -r "/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e" &>/dev/null; rv=$?

# sed will return return 0 regardless of whether it matched any rule
# sed will return other values if it fails for other reasons
if [ $rv -ne 0 ]; then
	echo "Failure."
	err="Error trying to remove existing rules with command: iptables-save | sed -r \"/INPUT.*comment.*$iptables_comment/s/-A/iptables -D/e\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## check if ipset with given name already exists and is non-empty
# we query ipset and check how many lines it gives for given ipset name.
# for non-existing sets that should be 0
# for existing empty sets that should be 7
# for existing non-empty sets that should be >7

ipset_length=$(ipset -L $ipset_name 2>/dev/null |  wc -l)

if [ $ipset_length -ge "7" ]; then
	echo -n "Found existing ipset \"$ipset_name\". Destroying... "
	ipset destroy "$ipset_name"; rv=$?
	if [ $rv -ne 0 ]; then
		err="Error $rv destroying ipset \"$ipset_name\". Exiting."
		echo ""
		die "$err"
	fi
	echo "Ok."
fi

if [ $ipset_length -eq 0 ]; then
	[ $debug ] && echo "Debug: Ipset \"$ipset_name\" doesn't exist yet."
	# to avoid being dependent on ipset output staying constant down the road,
	# still trying to delete the ipset, just in case, but not checking the return value
	ipset destroy "$ipset_name" &>/dev/null
fi


#create new ipset
echo -n "Creating new ipset \"$ipset_name\"... "
ipset create "$ipset_name" hash:net family "$family"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error trying to create ipset \"$ipset_name\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

# import whitelist into ipset from file
echo -n "Importing the whitelist file into ipset... "
for ip in `cat $whitelist_path`; do
	ipset add "$ipset_name" "$ip"; rv=$?
	if [ $rv -ne 0 ]; then
		err="Error trying to run the command: \"ipset add $ipset_name $ip\". Exiting."
		echo ""
		die "$err"
	fi
done
echo "Ok."

echo -n "Inserting rule to allow all traffic from the loopback interface... "
iptables -I INPUT -i lo -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to insert rules with command \"iptables -A INPUT -i lo -j ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."


echo -n "Inserting rule to allow established/related connections... "
iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to insert rules with command \"iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

# append the whitelist to the INPUT chain
echo -n "Appending the whitelist rule to the INPUT chain... "
iptables -A INPUT -m set --match-set "$ipset_name" src -j ACCEPT -m comment --comment "$iptables_comment"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to append ipset rules with command \"iptables -I INPUT -m set --match-set "$ipset_name" src -j ACCEPT\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

## configure iptables policies

# set policy on INPUT and FORWARD chains to DROP
echo -n "Setting default iptables policies for INPUT and FORWARD to DROP... "
iptables -P INPUT DROP; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to change iptables policy with command \"iptables -P INPUT DROP\". Exiting."
	echo ""
	die "$err"
fi

iptables -P FORWARD DROP; rv=$?
if [ $rv -ne 0 ]; then
	err="Error $rv trying to change iptables policy with command \"iptables -P FORWARD DROP\". Exiting."
	echo ""
	die "$err"
fi
echo "Ok."

# This line is to simulate a simple fault and test recovery from backup
# Activates when running the script with the -t switch
[ $test ] && die "Test test test"

## Create backup file for known-good iptables state and save current state to the file

echo -n "Creating backup of current iptables state... "
touch "$knowngood_file.new"

iptables-save > "$knowngood_file.new"; rv=$?
if [ $rv -ne 0 ]; then
	echo ""
	err="Error trying to create backup of iptables state with command: iptables-save > \"$knowngood_file.new\". Exiting." >&2
	die "$err"
fi
echo "Ok."

echo -n "Creating backup of current ipset... "

# we use the same file for iptables and ipset backup
# the "[IPSET]" line separates the two portions of the file
echo "[IPSET]" >> "$knowngood_file.new"

ipset save "$ipset_name" >> "$knowngood_file.new"; rv=$?
if [ $rv -ne 0 ]; then
	echo ""
	err="Error creating backup of ipset \"$ipset_name\". Exiting."
	die "$err"
fi
echo "Ok."

echo "Backup file: \"$knowngood_file\""

mv "$knowngood_file.new" "$knowngood_file"; rv=$?
if [ $rv -ne 0 ]; then
	err="Error overwriting backup file for ipset and iptables state. Exiting." >&2
	die "$err"
fi

echo ""
echo "Successfully applied new iptables rules."
echo ""
