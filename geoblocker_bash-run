#!/bin/bash -l

# geoblocker_bash-run

# Serves as a proxy to call the -fetch, -apply and -backup scripts with arguments required for the action.
#
# Supported actions: add, remove, update

# 'geoblocker_bash-run -a add -c <country_code>' : Calls the fetch script, then calls the apply script,
#    passing required arguments to fetch and apply ipset and iptables rules for the specified country.
#    If multiple countries are specified, repeats the operation for each country's ip list.

# 'geoblocker_bash-run -a remove -c <country_code>' : Calls the apply script,
#     passing required arguments to remove the ipset and iptables rules for the specified country.
#     If multiple countries are specified, repeats the operation for each country's ip list.

# 'geoblocker_bash-run -a update' : used for triggering from cron jobs.
#     Calls the fetch script (unless called with the -s - Skip fetch option), then calls the apply script,
#     passing required arguments to fetch and apply ipset and iptables rules for countries listed in the config file.
#     Used to update the ip lists at a periodic schedule, and to activate the rules on reboot.

# all actions:
#     If successful, calls the backup script to create backup of the current (known-good) iptables state and current ipset.
#     If an error is enountered, classifies it as a temporary or a permanent error.
#     Permanent errors mean that something is fundamentally broken. Temporary errors are transient (for example a download error).
#     For permanent errors, calls the -backup script to restore last known-good ipsets and iptables state.

me=$(basename "$0")
parent_script="$(ps -o args= $PPID | awk -v RS='/| ' '/^geoblocker/')"
args="$*"

#### USAGE

usage() {
    cat <<EOF

$me
Supported actions: add, remove, update.
Serves as a proxy to call the -fetch, -apply and -backup scripts with arguments required for each action.

    Usage: $me -a <update|add|remove> [-c <"tld [tld] ... [tld]">] [-s] [-p] [-d] [-h]

    Options:
        -a <action>          : action to perform: "update", "add" or "remove" associated iptables rules
        -c <"country_codes"> : tld's (country codes). if passing multiple country codes, use double quotes
        -s                   : Skip fetching (only run the apply script)
        -p                   : No Drop: applies the config but skips setting INPUT chain default policy to DROP
                                   (continue to accept all connections)

        -d                   : Debug
        -h                   : This help

EOF
}

#### PARSE ARGUMENTS

while getopts "a:c:spdh" opt; do
	case $opt in
		a) action=$OPTARG;;
		c) arg_tlds=$OPTARG;;
		s) skipfetch="true";;
		p) nodrop="-p";;
		d) debug="-d";;
		h) usage; exit 0;;
		\?) usage; exit 1;;
	esac
done
shift $((OPTIND -1))


#### FUNCTIONS

debugprint() {
# prints a debug message
	[ "$debug" ] && echo -e "    Debug: $*"
}

echo ""
debugprint "\033[1;33mStarted *run with args: '$args'\033[0m"

die() {
	echo ""
	echo "$2" 1>&2
	echo ""
	logger -t geoblocker_bash-run "$2"
	[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"
	exit "$1"
}

get_script_dir () {
	SOURCE=${BASH_SOURCE[0]}
	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
		SOURCE=$(readlink "$SOURCE")
		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
		# if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	done
	DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
	echo "$DIR"
}

getconfig() {
# reads a field named $1 from the config file $2
# outputs the resulting field
# returns 0 if successful, 1 if not
	fieldname="$1"
	configfile="$2"
	if [ -z "$fieldname" ] || [ -z "$configfile" ]; then return 1; fi
	read -r field < <(grep "$fieldname=" "$configfile" | sed "s/.*$fieldname=//"); rv=$?
	if [ -z "$field" ]; then
		echo ""
		rv=$((rv + 1))
	else
		echo "$field"
	fi
	return $rv
}


#### VARIABLES

conf_dir="/etc/geoblocker_bash"
conf_file="${conf_dir}/geoblocker_bash.conf"

# read datadir from the config file
read -r datadir < <(getconfig "Datadir" "$conf_file")

# read the path to backup_script from the config file
read -r backup_script < <(getconfig "Backup_script" "$conf_file")

preinstall_policies_file="$datadir/preinstall_policies.bak"
knowngood_file="$datadir/iptables_knowngood.bak"
whitelist_dir="$datadir/ip_lists"
tlds_status_file="$datadir/tlds_status"

if [ -z "$arg_tlds" ] || [ "$action" = "update" ]; then
	# read tlds from the config file
	debugprint "Loading tlds from file..."
	read -r tlds < <(getconfig "Countries" "$conf_file")
else
	tlds="$arg_tlds"
fi

# trim single-quotes if any
tlds="$(echo ${tlds//\'})"

# get the script path
read -r scriptdir < <(get_script_dir)


#### CHECKS

# check for geoblocker_bash-fetch
[ ! $skipfetch ] && if ! command -v geoblocker_bash-fetch &> /dev/null; then
	err="Error: Cannot find 'geoblocker_bash-fetch'. Did you run setup? Exiting."
	die 1 "$err"
fi

# check for geoblocker_bash-apply
if ! command -v geoblocker_bash-apply &> /dev/null; then
	err="Error: Cannot find 'geoblocker_bash-apply'. Did you run setup? Exiting."
	die 1 "$err"
fi

# check for geoblocker_bash-backup
if ! command -v geoblocker_bash-backup &> /dev/null; then
	err="Error: Cannot find 'geoblocker_bash-apply'. Did you run setup? Exiting."
	die 1 "$err"
fi

case "$action" in
	add) apply_action="add" ;;
	remove) apply_action="remove" ;;
	update) apply_action="add" ;;
	*) usage; die 1 "Error: unsupported action '$action'" ;;
esac

# check for country tlds
if [ -z "$tlds" ]; then
	err="tlds variable can not be empty! Exiting."
	usage
	die 1 "$err"
fi

if [ -z "$knowngood_file" ]; then
	err="Error: Known-good file path can not be empty! Exiting."
	usage
	die 1 "$err"
fi

if [ -z "$whitelist_dir" ]; then
	err="Error: Whitelist file path can not be empty! Exiting."
	usage
	die 1 "$err"
fi

# check for root
if [ "$EUID" -ne 0 ]; then
	err="This needs to be run as root."
	die 1 "$err"
fi


#### MAIN
debugprint "tlds to process: $tlds"

# cd into script directory
# exit in case "cd" fails
cd "$scriptdir"; rv=$?
if [ -z "$scriptdir" ] || [ "$rv" -ne 0 ]; then die 1 "Error: could not change directory to '$scriptdir'. Exiting."; fi


### Fetch ip lists
errcnt="0"
ok_cnt="0"
failed_tlds=""
ok_tlds=""
if [ ! "$skipfetch" ] && [ "$action" != "remove" ]; then
	for tld in $(echo "${tlds}"); do
		geoblocker_bash-fetch $debug -c "$tld" -p "$whitelist_dir"; rv=$?
		if [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
			# positive return value from fetch means fatal code error rather than fetch error, except for 254
			die 1 "Error in *fetch script, something is broken."
		fi
		if [ $rv -eq 254 ]; then
			errcnt=$(( errcnt + 1 ))
			failed_tlds="$(echo $failed_tlds) $tld"
			debugprint "Failed to retrieve ip list for country '$tld'."
		else
			ok_cnt=$(( ok_cnt + 1 ))
			ok_tlds="$(echo $ok_tlds) $tld"
			debugprint "Successfully retrieved ip list for country '$tld'."
		fi
	done

	if [ "$errcnt" -gt 0 ]; then
		msg="Failed to fetch the whitelist for countries'$failed_tlds'."
		echo "$msg"
		logger -t geoblocker_bash-run "$msg"
		echo "FailedTLDs=$failed_tlds" >> "$tlds_status_file"
	fi

	if [ "$ok_cnt" -gt 0 ]; then
		msg="Successfully fetched the whitelist for countries'$ok_tlds'."
		echo "$msg"
		logger -t geoblocker_bash-run "$msg"
		echo "OkTLDs=$ok_tlds" >> "$tlds_status_file"
	else
		err="All fetch attempts failed."
		die 254 "$err"
	fi

	tlds="$ok_tlds"
else
	echo "NOTE: Skipped fetching because -s switch was used"
fi


### Apply ip lists

for tld in $(echo "${tlds}"); do
	geoblocker_bash-apply $debug $nodrop -a "$apply_action" -c "$tld"; rv=$?
	if [ $rv -eq 254 ]; then
		echo ""
		# if non-fatal errors occur in *apply, exit with an error
		die 1 ""
	elif [ $rv -gt 0 ] && [ $rv -ne 254 ]; then
		echo ""
		#if fatal errors occur in *apply, attempt to restore last known-good ipsets and iptables state
		$backup_script $debug -f "$knowngood_file" -r
		die 1 ""
	else    # if the *apply script exited with code 0
		debugprint "Successfully applied action '$apply_action' for country '$tld'."
	fi
done

# call the backup script to create a known-good backup of ipsets and iptables state
$backup_script $debug -f "$knowngood_file" -b

logger -t geoblocker_bash-run "Successfully applied action '$action' for countries '$tlds'."

echo ""

if [ "$errcnt" -ne 0 ]; then rv=254; else rv=0; fi

[ -n "$parent_script" ] && debugprint "\033[1;33mBack to $parent_script...\033[0m"

exit "$rv"
